<!-- 
  ****************************************************
  * WARNING: This code is protected by copyright law. *
  * Unauthorized reproduction, distribution, or use   *
  * of this code, in whole or in part, is strictly    *
  * prohibited and may result in legal action.        *
  * For authorized use only.                          *
  ****************************************************
-->      

<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UnmatriXLab - Breathing App</title>
  <style>
    
    /*AYUDA FLOTANTE*/
     /* 
  Para que el botón se vea siempre POR ENCIMA de cualquier header fijo, 
  ponemos un z-index alto y lo separamos un poco de la parte superior (top:70px).
  Ajusta el valor de top según la altura real de tu header. 
*/

.page-id-229928 #main-header,
.page-id-229928 #main-footer {
    display: none !important;
}

.help-container {
  position: fixed;
  top: 100px;          /* 👈 Ajusta este valor si tu header es más alto */
  right: 20px;
  z-index: 999999;    /* Muy por encima de la mayoría de headers */
}

/* Media query opcional, para pantallas pequeñas (ej. < 600px) */
@media (max-width: 500px) {
  .help-container {
    left: 10px;       /* Asegura que quede al menos a 10px del borde izquierdo */
    right: 10px;      /* Igual para el derecho */
  }
  .help-panel {
    width: 100%;      /* O usa width: auto; y un max-width menor */
    max-width: calc(100vw - 20px); /* Para que nunca se exceda el ancho del viewport */
  }
}



/* Botón circular */
.help-button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  color: rgba(255, 255, 255, 0.5);
  border: none;
  cursor: pointer;
  font-size: 20px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  transition: background-color 0.3s;
  margin-top: 0px; /* Default for web */
}

.help-button:hover {
  background-color: #333;
}

/* Ajuste para móviles */
@media (max-width: 768px) {
  .help-button {
    margin-top: -75px; /* Ajuste específico para la app móvil */
  }
}

/* Panel de ayuda con scroll interno */
.help-panel {
  position: absolute;
  top: 60px;          /* Para que salga debajo del botón */
  right: 0;
  width: 400px;
  max-height: 300px;  /* Limitamos la altura */
  overflow-y: auto;   /* Scroll si excede la altura */
  padding: 15px;
  background-color: rgba(0, 0, 0, 0.7);

  border: 1px solid #ccc;
  border-radius: 6px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.9);
  display: none; 
}

.help-panel h3 {
  margin-top: 0;
  font-size: 18px;
  margin-bottom: 8px;
  color: rgba(26, 144, 184, 1); /*Azul h3*/
text-align: center; /* Centra texto e hijos en línea */

 /* Estilos para la línea */
  border-bottom: 1px solid #ccc; /* Color y grosor de la línea */
  padding-bottom: 8px;          /* Separación del texto respecto a la línea */
}
.help-panel p {
  font-size: 14px;
  margin-bottom: 12px;
  line-height: 1.5;
color: rgba(255, 255, 255, 1); /*Azul h3*/
}

/* Transiciones de aparición/desaparición */
.fade-in {
  animation: fadeIn 0.3s forwards;
}
.fade-out {
  animation: fadeOut 0.3s forwards;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-5px); }
  to   { opacity: 1; transform: translateY(0);   }
}
@keyframes fadeOut {
  from { opacity: 1; transform: translateY(0);   }
  to   { opacity: 0; transform: translateY(-5px);}
}
    /*FIN AYUDA FLOTANTE*/
    /* ======== Hacer Todo No Seleccionable ======== */
    * {
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none;     /* IE 10 y IE 11 */
      user-select: none;         /* Estándar */
    }

    input, textarea, button {
    user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
}

* {
  -webkit-tap-highlight-color: transparent;
}


    
    :root {
         background: radial-gradient(circle, #08161c, #03080a );
        --knob-color: #324e57;
       
       --label-color: #00bcd4;

      --circle-color-light1: rgba(166, 216, 255, 0.8);
      --circle-color-light2: rgba(116, 186, 255, 0.8);
      --circle-color-light3: rgba(66, 156, 255, 0.8);
      --circle-color-light4: rgba(26, 126, 233, 0.8);
      --my-extra-celeste: rgba(0, 236, 255, 0.8);

      --my-hue: 0deg;

      --text-color: #ffffff;
      --box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.2);

      --large-circle-size: 90%;
      --small-circle-size: 60px;
      --gap: 20px;

      --outer-margin: 8px;
      --outer-padding: 0;
    }

    @media (min-width: 1024px) {
      :root {
        --large-circle-size: 34%;
      }
    }

    

     body {
      background-color: #000 !important;
      background: var(--background);
      color: var(--text-color);
      margin: 0;
      padding: 0;
      height: auto;
      min-height: auto;
      user-select: none;
      font-family: Arial, sans-serif;

    }

.app-container {
  background-color: #000;
  min-height: auto;
}


    /* ======== Estilos para la Animación de Aves ======== */
    .bird {
      background-image: url('https://unmatrixlab.com/wp-content/uploads/2025/01/bird-cells-new.svg');
      filter: invert(100%) sepia(55%) saturate(427%) hue-rotate(141deg) brightness(93%) contrast(91%);
      background-size: auto 100%;
      width: 88px;
      height: 125px;
      will-change: background-position;
      animation-name: fly-cycle;
      animation-timing-function: steps(10);
      animation-iteration-count: infinite;
      opacity: 0.1; /* Nivel de transparencia, ajustable entre 0 y 1 */
    }

    .bird-one {
      animation-duration: 1s;
      animation-delay: -0.9s;
    }

    .bird-two {
      animation-duration: 0.9s;
      animation-delay: -0.75s; 
    }

    .bird-three {
      animation-duration: 1.25s;
      animation-delay: -0.25s;
    }

    .bird-four {
      animation-duration: 1.1s;
      animation-delay: -0.5s;
    }

    .bird-container {
      position: absolute;
      top: 10%;
      left: -3%;
      transform: scale(0) translateX(-10vw);
      will-change: transform;
      animation-name: fly-right-one;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
      opacity: 1;
      transition: opacity 0.3s ease;
    }
      
    .bird-container-one {
      animation-duration: 15s; /* Duración de la animación */
      animation-delay: 10s;    /* Comienza inmediatamente */
    }

    .bird-container-two {
      animation-duration: 15s; /* Duración de la animación */
      animation-delay: 11s;    /* Comienza 15 segundos después */
    }

    .bird-container-three {
      animation-duration: 15s; /* Duración de la animación */
      animation-delay: 300s;   /* Comienza 30 segundos después */
    }

    .bird-container-four {
      animation-duration: 16s; /* Duración de la animación */
      animation-delay: 302s;   /* Comienza 45 segundos después */
    }

    @keyframes fly-cycle {
      100% {
        background-position: -900px 0;
      }
    }

    @keyframes fly-right-one {
      0% {
        transform: scale(0.3) translateX(-10vw);
      }
      10% {
        transform: translateY(2vh) translateX(10vw) scale(0.4);
      }
      20% {
        transform: translateY(0vh) translateX(30vw) scale(0.5);
      }
      30% {
        transform: translateY(4vh) translateX(50vw) scale(0.6);
      }
      40% {
        transform: translateY(2vh) translateX(70vw) scale(0.6);
      }
      50% {
        transform: translateY(0vh) translateX(90vw) scale(0.6);
      }
      60% {
        transform: translateY(0vh) translateX(110vw) scale(0.6);
      }
      100% {
        transform: translateY(0vh) translateX(110vw) scale(0.6);
      }
    }

    @keyframes fly-right-two {
      0% {
        transform: translateY(-2vh) translateX(-10vw) scale(0.5);
      }
      10% {
        transform: translateY(0vh) translateX(10vw) scale(0.4);
      }
      20% {
        transform: translateY(-4vh) translateX(30vw) scale(0.6);
      }
      30% {
        transform: translateY(1vh) translateX(50vw) scale(0.45);
      }
      40% {
        transform: translateY(-2.5vh) translateX(70vw) scale(0.5);
      }
      50% {
        transform: translateY(0vh) translateX(90vw) scale(0.45);
      }
      51% {
        transform: translateY(0vh) translateX(110vw) scale(0.45);
      }
      100% {
        transform: translateY(0vh) translateX(110vw) scale(0.45);
      }
    }
    /* ======== FIN Estilos para la Animación de Aves ======== */

    .unmatrix-lab-wrapper {
      //margin: var(--outer-margin) auto;
      padding: var(--outer-padding);
      max-width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--gap);
      position: relative;
    }
.unmatrix-lab-large-circle {
  visibility: hidden; /* Oculto inicialmente */
  width: var(--large-circle-size);
  aspect-ratio: 1;
  border-radius: 50%;
  box-shadow: var(--box-shadow);
  background: conic-gradient(
    var(--circle-color-light1) 0deg,
    var(--circle-color-light1) 90deg,
    var(--circle-color-light2) 90deg 180deg,
    var(--circle-color-light3) 180deg 270deg,
    var(--circle-color-light4) 270deg 360deg
  );
  position: relative;
  overflow: hidden;
  margin: 0 auto;
  margin-top: 35px; /* Valor por defecto para web */
  box-shadow: 0px 0px 30px 11px rgba(169, 233, 245, 0.9);
  z-index: 10;
  filter: hue-rotate(var(--my-hue));
}

/* Para dispositivos móviles */
@media (max-width: 768px) {
  .unmatrix-lab-large-circle {
   margin-top: -45px; /* Ajuste específico para la app móvil */
  }
}

.unmatrix-lab-large-circle::before { 
  content: "";
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  border-radius: 50%;
  //background-image: url('https://unmatrixlab.com/wp-content/uploads/2025/01/Lake-Sounds.png');
   background-image: var(--background-image);
  background-size: cover;
  background-position: center;
  z-index: -10; /* Asegura que esté detrás */
  opacity: 0.3; /* Puedes ajustar la opacidad para ver cómo interactúan los colores */
}

    #phase-highlight {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 3;
    }

    .needles-container {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .needle {
      position: absolute;
      width: 2px;
      height: 50%;
      background-color: #fff;
      left: 50%;
      bottom: 50%;
      transform-origin: 50% 100%;
      transform: rotate(0deg);
      transition: none;
     // z-index: 2;
    }
    .needle-long {
      background-color: #94efff;
      box-shadow: 0px 0px 25px 12px rgba(0, 191, 255, 0.6);
      width: 1px;
    }
    .needle-short {
      background-color: #ffffff;
      box-shadow: 0px 0px 25px 12px rgba(255, 255, 255, 0.6);
      width: 1px;
    }

    .needle-temp {
      position: absolute;
      width: 1px;
      height: 50%;
      background-color: rgba(212, 255, 0, 0.9);
      left: 50%;
      bottom: 50%;
      transform-origin: 50% 100%;
      transform: rotate(0deg);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      box-shadow: 0px 0px 25px 12px rgba(255, 255, 255, 0.6);
      //z-index: 3;
    }

    #temp-value {
      position: absolute;
      top: 15px; left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.8);
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 4;
      text-shadow: 0px 2px 4px rgba(0, 0, 0, 0.9);
      font-size: 18px; 
    }

    #phase-highlight-value {
      position: absolute;
      top: 15px; left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.9);
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 5;
      text-shadow: 0px 2px 4px rgba(0, 0, 0, 0.9);
      font-size: 18px; 
    }

    .unmatrix-lab-small-circles {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .unmatrix-lab-small-circles > .unmatrix-lab-small-circle:nth-child(1) {
      //background-color: rgba(166, 216, 255,1) ;
      //background: radial-gradient(circle, #376275, #0f2933);
     // background: radial-gradient(circle, rgba(166, 216, 255,0.8)  10%, rgba(166, 216, 255, 0.4) 100%);
      background: radial-gradient(circle, rgba(30, 144, 186,0.2)  10%, rgba(30, 113, 186, 0.3) 100%);
      box-shadow: 0px 0px 27px rgba(255, 255, 255, 0.9)!important;
    }
    .unmatrix-lab-small-circles > .unmatrix-lab-small-circle:nth-child(2) {
      //background-color: rgba(116, 186, 255, 1) ;
      //background: radial-gradient(circle, rgba(116, 186, 255, 0.9)  10%, rgba(116, 186, 255, 0.5) 100%);
      background: radial-gradient(circle, rgba(30, 144, 230,0.2)  10%, rgba(30, 113, 186, 0.3) 100%);
       box-shadow: 0px 0px 35px rgba(255, 255, 255, 0.8);
    }
    .unmatrix-lab-small-circles > .unmatrix-lab-small-circle:nth-child(3) {
      //background-color: rgba(66, 156, 255, 1) ;
      //background: radial-gradient(circle, rgba(66, 156, 255, 1) 10%, rgba(66, 156, 255, 0.6) 100%);
      background: radial-gradient(circle, rgba(30, 144, 186,0.2)  10%, rgba(30, 113, 186, 0.3) 100%);
       box-shadow: 0px 0px 40px rgba(255, 255, 255, 0.7);
    }
    .unmatrix-lab-small-circles > .unmatrix-lab-small-circle:nth-child(4) {
     // background-color: rgba(26, 126, 233, 1) ;
     //background: radial-gradient(circle, rgba(26, 126, 233, 0.9) 10%, rgba(26, 126, 233, 0.5)  100%);
     background: radial-gradient(circle, rgba(30, 144, 220,0.2)  10%, rgba(30, 113, 186, 0.3) 100%);
       box-shadow: 0px 0px 35px rgba(255, 255, 255, 0.8);
    }
    .unmatrix-lab-small-circles > .unmatrix-lab-small-circle:nth-child(5) {
      //background-color: rgba(0, 236, 255, 1) ;
      //background: radial-gradient(circle, rgba(0, 236, 255, 0.8) 10%, rgba(0, 236, 255, 0.4)  100%);
      background: radial-gradient(circle, rgba(30, 144, 186,0.2)  10%, rgba(30, 113, 186, 0.3) 100%);
       box-shadow: 0px 0px 27px rgba(255, 255, 255, 0.9);
    }


    .unmatrix-lab-small-circle {
      width: 60px;
      aspect-ratio: 1;
      border-radius: 50%;
      background-color: transparent; 
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      touch-action: none;
    }
    .unmatrix-lab-small-circle input {
      background: none;
      border: none;
      text-align: center;
      width: 100%;
      height: 100%;
      font-size: 1rem;
      font-weight: bold;
      color: rgba(255, 255, 255, 0.9);
      font-size: 17px; 
      text-shadow: 0px 0px 4px rgba(0, 0, 0, 0.8);
      
    }
    .unmatrix-lab-small-circle input:focus {
      outline: none;
    }

    .master-fader-container,
    .gong-fader-container,
    .ambient-fader-container,
    .music-voice-training-fader-container {
      width: 85%;
      margin: 20px auto;
      max-width: 600px;
      text-align: center;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: nowrap;
    }

    .slider-container-master,
    .slider-container-gong,
    .slider-container-gong-final,
    .slider-container-ambient,
    .slider-container-music,
    .slider-container-voice-training {
      flex: 1;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      min-width: 100px;
    }

    .slider-container-master label,
    .slider-container-gong label,
    .slider-container-gong-final label,
    .slider-container-ambient label,
    .slider-container-music label,
    .slider-container-voice-training label,
    .slider-container-eqlow label,
    .slider-container-eqmid label,
    .slider-container-eqhigh label, 
    .eq-toggle-container label ,
    .slider-container-longfade label,
    .fadeOutProgress,    
    .fadeOutLabel {
      font-size: 16px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      color: var(--label-color, #00bcd4);//color: #00bcd4;//??????
      text-shadow: 3px 3px 3px #ffbcd4;
      //opacity: 0.8; 
      //text-shadow: 0px 0px 4px rgba(0, 0, 0, 0.8);
      white-space: nowrap;   /* Asegura que el texto se mantenga en una línea */
    }

    .eq-toggle-container label{margin-bottom:-3px;}

    #voice-training-label {
  cursor: pointer;
}

#voice-training-label.feedback {
  color: rgba(228, 240, 10); /* Un tono de azul/teal semitransparente */
  transition: background-color 0.3s ease;
}

    .mute-button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
      margin-left: 10px;
      margin-right: -10px;
      transition: color 0.3s;
    }
    .mute-button.muted {
      color: red;
    }

    .slider-container-master input[type="range"],
    .slider-container-gong input[type="range"],
    .slider-container-gong-final input[type="range"],
    .slider-container-ambient input[type="range"],
    .slider-container-music input[type="range"],
    .slider-container-voice-training input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 1px;
      border-radius: 4px;
      background: #b2dfdb;
      outline: none;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
      transition: background 0.3s ease, box-shadow 0.3s ease;
      cursor: pointer;
    }
    .slider-container-master input[type="range"]::-webkit-slider-runnable-track,
    .slider-container-gong input[type="range"]::-webkit-slider-runnable-track,
    .slider-container-gong-final input[type="range"]::-webkit-slider-runnable-track,
    .slider-container-ambient input[type="range"]::-webkit-slider-runnable-track,
    .slider-container-music input[type="range"]::-webkit-slider-runnable-track,
    .slider-container-voice-training input[type="range"]::-webkit-slider-runnable-track{
      width: 100%;
      height: 1px;
      background: #669999;
      border-radius: 4px;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }
    .slider-container-master input[type="range"]::-moz-range-track,
    .slider-container-gong input[type="range"]::-moz-range-track,
    .slider-container-gong-final input[type="range"]::-moz-range-track,
    .slider-container-ambient input[type="range"]::-moz-range-track,
    .slider-container-music input[type="range"]::-moz-range-track,
    .slider-container-voice-training input[type="range"]::-moz-range-track {
      width: 100%;
      height: 6px;
      background: #669999;
      border-radius: 4px;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }
    .slider-container-master input[type="range"]::-ms-track,
    .slider-container-gong input[type="range"]::-ms-track,
    .slider-container-gong-final input[type="range"]::-ms-track,
    .slider-container-ambient input[type="range"]::-ms-track,
    .slider-container-music input[type="range"]::-ms-track,
    .slider-container-voice-training input[type="range"]::-ms-track {
      width: 100%;
      height: 6px;
      background: transparent;
      border-color: transparent;
      color: transparent;
    }
    .slider-container-master input[type="range"]::-webkit-slider-thumb,
    .slider-container-gong input[type="range"]::-webkit-slider-thumb,
    .slider-container-gong-final input[type="range"]::-webkit-slider-thumb,
    .slider-container-ambient input[type="range"]::-webkit-slider-thumb,
    .slider-container-music input[type="range"]::-webkit-slider-thumb,
    .slider-container-voice-training  input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px; 
      height: 20px;
      border-radius: 50%;
      background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      margin-top: -9px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transition: background 0.2s ease, box-shadow 0.3s ease;  
      
    }
    .slider-container-master input[type="range"]::-moz-range-thumb,
    .slider-container-gong input[type="range"]::-moz-range-thumb,
    .slider-container-gong-final input[type="range"]::-moz-range-thumb,
    .slider-container-ambient input[type="range"]::-moz-range-thumb,
    .slider-container-music input[type="range"]::-moz-range-thumb,
    .slider-container-voice-training input[type="range"]::-moz-range-thumb {
      width: 20px; 
      height: 20px;
      border-radius: 50%;
      background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      
    }
    .slider-container-master input[type="range"]:active::-webkit-slider-thumb,
    .slider-container-gong input[type="range"]:active::-webkit-slider-thumb,
    .slider-container-gong-final input[type="range"]:active::-webkit-slider-thumb,
    .slider-container-ambient input[type="range"]:active::-webkit-slider-thumb,
    .slider-container-music input[type="range"]:active::-webkit-slider-thumb,
    .slider-container-voice-training  input[type="range"]:active::-webkit-slider-thumb,
    .slider-container-master input[type="range"]:active::-moz-range-thumb,
    .slider-container-gong input[type="range"]:active::-moz-range-thumb,
    .slider-container-gong-final input[type="range"]:active::-moz-range-thumb,
    .slider-container-ambient input[type="range"]:active::-moz-range-thumb,
    .slider-container-music input[type="range"]:active::-moz-range-thumb,
    .slider-container-voice-training input[type="range"]:active::-moz-range-thumb {
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
      background-color: var(--knob-color);
    }

    /* ======== ESTILOS PARA DROPDOWNS ======== */
    preset-dropdown,
    gong-dropdown,
    ambient-dropdown,
    music-voice-training-dropdown {
      width: 85%;
      margin: 20px auto;
      max-width: 600px;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
    }

    .dropdown-content {
      position: relative;
      max-height: 400px;
      overflow-y: auto;
      border: 4px solid #ccc;
      border-radius: 4px;
      box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
      padding: 10px;
      box-sizing: border-box;
      background-color: #485759;
      color: #ffffff;
      display: none;
    }
    .dropdown-content.show {
      display: block;
    }

    .dropdown-item {
      display: flex; 
      align-items: center;
      padding: 8px; 
      cursor: pointer;
      transition: background-color 0.3s;
      border-top: 1px solid #eee;
      position: relative;
    }
    .dropdown-item:hover {
      background-color: #304245;
    }
    .dropdown-item:first-child {
      border-top: none;
    }
    .indicator {
      width: 10px; 
      height: 10px;
      border-radius: 50%;
      background-color: transparent;
      border: 1px solid #ccc;
      margin-right: 10px;
      transition: background-color 0.3s;
    }
    .dropdown-item.selected .indicator {
      background-color: #35cae8;
      border-color: #35cae8;
    }
    .button-group {
      display: flex; 
      justify-content: space-between;
      gap: 10px; 
      margin-bottom: 10px;
    }
    .button {
      flex: 1;
      padding: 10px; 
      font-size: 14px; 
      text-align: center;
      border: 1px solid #ccc; 
      border-radius: 4px;
      background-color: #2b3633;
      color: #ffcc00 !important;
      cursor: pointer;
      display: flex; 
      align-items: center; 
      justify-content: center;
      transition: background-color 0.3s;
    }
    .button:hover {
      background-color: #304245;
    }
    .dropdown-separator {
      border-top: 2px solid #ccc;
      margin: 10px 0;
    }
    strong {
      display: block;
      margin: 10px 0 5px 0;
      color: #ffcc00;
    }

/*EQ*/
/* ====================== checkbox eq  ====================== */

/* ====================== CONTENEDOR DEL CHECKBOX DE EQ ====================== */
.eq-toggle-container {
  width: 85%;
  margin: 20px auto;
  max-width: 600px;
  font-family: Arial, sans-serif;
  box-sizing: border-box;

  /* Para alinear horizontalmente: */
  display: flex; 
  align-items: center;
  justify-content: flex-start; /* O space-between, según prefieras */
  gap: 20px;  /* Espacio horizontal entre EQ y FadeOut */
  text-align: left; /* Quita centrado si no deseaslo */
}

/* //////*/
/* Oculta el checkbox nativo */

/* Estilo del checkbox */
#toggleEQ {
    appearance: none;
    width: 24px;
    height: 20px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: #404245; /* Siempre blanco por defecto */
    cursor: pointer;
    position: relative;
    transition: border-color 0.3s ease;
}


/* Se crea una pseudo-capa con el gradiente */
#toggleEQ::before {
    content: "";
    position: absolute;
    inset: 0;
    //background: linear-gradient(45deg, #4CAF50, #00C6FF);
    background: linear-gradient(60deg, #e4f00a, #fff);
    border-radius: 4px;
    opacity: 0; /* Oculto por defecto */
    transition: opacity 0.3s ease;
}

/* Cuando está marcado, se muestra el gradiente */
#toggleEQ:checked::before {
    opacity: 1; /* Se activa el gradiente sin parpadeo */
}

/* Borde cambia cuando está activado */
#toggleEQ:checked {
    border-color: #ccc;//var(--knob-color);//#00C6FF;
}

/* //////*/

/* Estilo para la Etiqueta del Checkbox */
//.eq-toggle-container label {
  //font-size: 16px;
  //color: #000000;//#00bcd4;
  //cursor: pointer;
//}
/* ====================== CONTENEDORES DE LOS SLIDERS DE EQ ====================== */
.eq-fader-container {
  width: 85%;
  margin: 20px auto;
  max-width: 600px;
  text-align: center;
  font-family: Arial, sans-serif;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: nowrap;
}

/* ====================== CONTENEDORES INDIVIDUALES DE LOS SLIDERS DE EQ ====================== */
.slider-container-eqlow,
.slider-container-eqmid,
.slider-container-eqhigh {
  flex: 1;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  min-width: 100px;
}

/* ====================== ETIQUETAS DE LOS SLIDERS DE EQ ====================== */
//.slider-container-eqlow label,
//.slider-container-eqmid label,
//.slider-container-eqhigh label {
 // font-size: 16px;
 // margin-bottom: 5px;
 // display: flex;
 // align-items: center;
 // justify-content: space-between;
 // width: 100%;
 // color: #00bcd4;
//}

/* ====================== INPUTS DE LOS SLIDERS DE EQ ====================== */
.slider-container-eqlow input[type="range"],
.slider-container-eqmid input[type="range"],
.slider-container-eqhigh input[type="range"] {
  -webkit-appearance: none;
  width: 100%;
  height: 1px;
  border-radius: 4px;
  background: #b2dfdb;
  outline: none;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
  transition: background 0.3s ease, box-shadow 0.3s ease;
  cursor: pointer;
}

/* ====================== TRACK DEL SLIDER ====================== */
.slider-container-eqlow input[type="range"]::-webkit-slider-runnable-track,
.slider-container-eqmid input[type="range"]::-webkit-slider-runnable-track,
.slider-container-eqhigh input[type="range"]::-webkit-slider-runnable-track {
  width: 100%;
  height: 1px;
  background: #669999;
  border-radius: 4px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}

.slider-container-eqlow input[type="range"]::-moz-range-track,
.slider-container-eqmid input[type="range"]::-moz-range-track,
.slider-container-eqhigh input[type="range"]::-moz-range-track {
  width: 100%;
  height: 6px;
  background: #669999;
  border-radius: 4px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}

.slider-container-eqlow input[type="range"]::-ms-track,
.slider-container-eqmid input[type="range"]::-ms-track,
.slider-container-eqhigh input[type="range"]::-ms-track {
  width: 100%;
  height: 6px;
  background: transparent;
  border-color: transparent;
  color: transparent;
}

/* ====================== THUMB DEL SLIDER ====================== */
/* WebKit (Chrome, Safari) */
.slider-container-eqlow input[type="range"]::-webkit-slider-thumb,
.slider-container-eqmid input[type="range"]::-webkit-slider-thumb,
.slider-container-eqhigh input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px; 
  height: 20px;
  border-radius: 50%;
    background-color: var(--knob-color);
  border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  margin-top: -9px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  transition: background 0.3s ease, box-shadow 0.3s ease;
}

.slider-container-eqlow input[type="range"]::-moz-range-thumb,
.slider-container-eqmid input[type="range"]::-moz-range-thumb,
.slider-container-eqhigh input[type="range"]::-moz-range-thumb {
  width: 20px; 
  height: 20px;
  border-radius: 50%;
    background-color: var(--knob-color);
  border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.slider-container-eqlow input[type="range"]:active::-webkit-slider-thumb,
.slider-container-eqmid input[type="range"]:active::-webkit-slider-thumb,
.slider-container-eqhigh input[type="range"]:active::-webkit-slider-thumb,
.slider-container-eqlow input[type="range"]:active::-moz-range-thumb,
.slider-container-eqmid input[type="range"]:active::-moz-range-thumb,
.slider-container-eqhigh input[type="range"]:active::-moz-range-thumb {
  box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    background-color: var(--knob-color);
}

/* ====================== VALORES DE LOS SLIDERS ====================== */
.slider-container-eqlow span,
.slider-container-eqmid span,
.slider-container-eqhigh span {
  margin-top: 0px;
  font-size: 14px;
  //color: rgb(128, 128, 128);



  color: var(--label-color, #00bcd4);//color: #00bcd4;//??????

     // text-shadow: 3px 3px 3px #ffbcd4;
}

/* ====================== OCULTAR EL CONTENEDOR DE EQ POR DEFECTO ====================== */
#eqControls {
  display: none;
  opacity: 0;
  transition: opacity 0.5s ease;
}

/* ====================== MOSTRAR EL CONTENEDOR DE EQ ====================== */
#eqControls.visible {
  display: flex;
  opacity: 1;
  transition: opacity 0.5s ease;
}
/*EQ FIN*/

.longfade-fader-container {
  width: 85%;
  margin: 20px auto;
  max-width: 600px;
  text-align: center;
  font-family: Arial, sans-serif;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: nowrap;
}

.slider-container-longfade {
  flex: 1;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  min-width: 100px;
}

//.slider-container-longfade label {
  //font-size: 16px;
 // margin-bottom: 5px;
  //display: flex;
 // align-items: center;
  //justify-content: space-between;
  //width: 100%;
  //color: #00bcd4;
//}

.slider-container-longfade input[type="range"] {
  -webkit-appearance: none;
  width: 100%;
  height: 1px;
  border-radius: 4px;
  background: #b2dfdb;
  outline: none;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
  transition: background 0.3s ease, box-shadow 0.3s ease;
  cursor: pointer;
}

.slider-container-longfade input[type="range"]::-webkit-slider-runnable-track {
  width: 100%;
  height: 1px;
  background: #669999;
  border-radius: 4px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}

.slider-container-longfade input[type="range"]::-moz-range-track {
  width: 100%;
  height: 6px;
  background: #669999;
  border-radius: 4px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}

.slider-container-longfade input[type="range"]::-ms-track {
  width: 100%;
  height: 6px;
  background: transparent;
  border-color: transparent;
  color: transparent;
}

.slider-container-longfade input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px; 
  height: 20px;
  border-radius: 50%;
    background-color: var(--knob-color);
  border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  margin-top: -9px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  transition: background 0.3s ease, box-shadow 0.3s ease;
}

.slider-container-longfade input[type="range"]::-moz-range-thumb {
  width: 20px; 
  height: 20px;
  border-radius: 50%;
    background-color: var(--knob-color);
  border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.slider-container-longfade input[type="range"]:active::-webkit-slider-thumb,
.slider-container-longfade input[type="range"]:active::-moz-range-thumb {
  box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    background-color: var(--knob-color);
}



/* === SPINNER (LOADING) === */
/* === SPINNER (LOADING) REEMPLAZADO POR UN RELOJ DE ARENA === */
.loading-spinner {
  position: absolute;
  top: 84%; 
  left: 50%;
  transform: translate(-50%, -50%);
  display: none;              /* Oculto por defecto */
  pointer-events: none;
  z-index: 5;
}

/* Spinner rotatorio */
.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.3); /* Borde semitransparente */
  border-top: 4px solid #fff;                 /* Borde superior en color blanco */
  border-radius: 50%;
  animation: spin 1s linear infinite;         /* Animación de rotación */
}

/* Definición de la animación */
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}



/* === MENSAJE DE FADE OUT + BARRA === */
.end-session-message {
  position: absolute;
  display: inline-block;      /* Hace que se muestre en una nueva línea */
  white-space: nowrap; 
  top: 65%; 
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.0); /* Semitransparente si quieres */
  color: #fff;
  border-radius: 40px;
  padding: 20px 30px;
  font-family: Arial, sans-serif;
  font-size: 1.5rem;
  text-align: center;
  pointer-events: none;
  opacity: 0;                 /* empieza invisible */
  transition: opacity 0.3s ease;
  z-index: 6;                 /* un poco más alto que el spinner */
  
}

.end-session-message .sub-message {
  display: inline-block;      /* Hace que se muestre en una nueva línea */
  white-space: nowrap; 
  font-size: 0.8em;      /* Mitad del tamaño de fuente del elemento padre */
  opacity: 1;          /* Semitransparente */
  margin-top: 10px;      /* Separación superior */
  text-align: center;    /* Centrado */
  color: #fff;           /* Color, puedes ajustarlo según tus necesidades */

}

/* Contenedor de la barra de progreso “Long Fade” */
.long-fade-bar-container {
   position: relative; /* Asegura que los ajustes de transformación funcionen */
  margin-top: 10px;
  width: 160%; /* Mantén el ancho aumentado */
  height: 8px;
  background: rgba(64, 66, 69, 0.3);
  border-radius: 4px;
  border-color: #ffffff;
  overflow: hidden;
  left: 50%;  /* Mueve el centro del div a la mitad */
  transform: translateX(-50%); /* Lo devuelve la mitad de su tamaño para centrarlo */
  z-index: 9999999;
}

/* Barra relleno */
.long-fade-bar-fill {
  width: 0%;
  height: 100%;
  background-color: #fff;
  border-radius: 4px;
  transition: width 0.2s ease;
}

/* === MENSAJE DE FADE OUT + BARRA === */
.session-paused-message {
  position: absolute;
  top: 65%; 
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.0); /* Semitransparente si quieres */
  color: #fff;
  border-radius: 40px;
  padding: 20px 30px;
  font-family: Arial, sans-serif;
  font-size: 1.2rem;
  text-align: center;
  pointer-events: none;
  opacity: 0;                 /* empieza invisible */
  transition: opacity 0.3s ease;
  z-index: 6;                 /* un poco más alto que el spinner */
    display: inline-block; /* Evita los saltos de línea */
  white-space: nowrap;   /* Asegura que el texto se mantenga en una línea */
}

.session-relax-message {
  position: absolute;
  top: 25%; 
  left: 50%;
  /* Establece el transform base igual al keyframe 0% y 100% */
  transform: translate(-50%, -50%) scale(0.99);
  background-color: rgba(0, 0, 0, 0.0);
  color: #fff;
  border-radius: 40px;
  padding: 20px 30px;
  font-family: Arial, sans-serif;
  font-size: 1.7rem;
  text-align: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 1.5s ease;
  z-index: 6;
  display: inline-block;
  white-space: nowrap;
  text-shadow: 0px 0px 30px rgba(255,255,255, 1);
}

/* Keyframes para la animación de pulso */
@keyframes relaxPulse {
  0% {
    transform: translate(-50%, -50%) scale(0.99);
  }
  50% {
    transform: translate(-50%, -50%) scale(0.98);
  }
  100% {
    transform: translate(-50%, -50%) scale(0.99);
  }
}

/* Al mostrar el mensaje, aplicamos la animación y mantenemos los valores iniciales/finales */
.session-relax-message.visible {
  opacity: 0.7;
  animation: relaxPulse 2.8s ease-in-out infinite;
  animation-fill-mode: both;
}


/* === MENSAJE DE TRES LÍNEAS SIN SALTOS === */
.three-line-message {
  position: absolute;
  top: 65%; /* Ubicación debajo del mensaje de Fade Out */
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.0); /* Semitransparente */
  color: #fff;
  border-radius: 40px;
  padding: 10px 20px;
  font-family: Arial, sans-serif;
  font-size: 1.2rem;
  text-align: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.9s ease;
  z-index: 6;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.three-line-message .line {
  display: inline-block; /* Evita los saltos de línea */
  white-space: nowrap;   /* Asegura que el texto se mantenga en una línea */
  margin: 0 5px;        /* Espacio entre los elementos */
}

.one-line-message {
  position: absolute;
  top: 65%; /* Ubicación debajo del mensaje de Fade Out */
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.0); /* Semitransparente */
  color: #fff;
  border-radius: 40px;
  padding: 10px 20px;
  font-family: Arial, sans-serif;
  font-size: 1.2rem;
  text-align: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.9s ease;
  z-index: 6;
  flex-direction: column;
  align-items: center;
  display: inline-block; /* Evita los saltos de línea */
  white-space: nowrap;   /* Asegura que el texto se mantenga en una línea */
}

  /* --- Si quieres cambiar el color del texto dentro del input, por ejemplo a amarillo --- */
  .unmatrix-lab-small-circle.active-phase input {
    color: #00C6FF;
    font-weight: bold;
  }


   .circle-swipe-message {
  position: absolute;
  top: 95%; /* Ubicación debajo del mensaje de Fade Out */
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.0); /* Semitransparente */
  color: #fff;
  border-radius: 40px;
  padding: 10px 20px;
  font-family: Arial, sans-serif;
  font-size: 1.1rem;
  text-align: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.9s ease;
  z-index: 6;
  display: flex;
  flex-direction: column;
  align-items: center;
    }

  /* ======== ESTE ES EL NUEVO MENSAJE PARA SOUND HOLD ======== */
    #sound-hold-message {
  position: absolute;
  top: 65%; /* Ubicación debajo del mensaje de Fade Out */
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.0); /* Semitransparente */
  color: #fff;
  border-radius: 40px;
  padding: 10px 20px;
  font-family: Arial, sans-serif;
  font-size: 1.2rem;
  text-align: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.9s ease;
  z-index: 6;
  display: flex;
  flex-direction: column;
  align-items: center;
    }



  </style>
</head>
<body>



<div class="help-container">
  <button id="help-button" class="help-button" style="background-color: rgba(85, 85, 85, 0.2);">?</button>
  <div id="help-panel" class="help-panel">
    <h3>Breathe Flow Help</h3>

<p>
The <b style="color: yellow;">UnmatriXLab</b> app <b style="color: cyan;">Breathe Flow</b> is a customizable breathing trainer designed to enhance relaxation and mindfulness. It features adjustable timers for inhalation, retention, and exhalation phases, alongside a total session duration. Users can select ambient sounds, guided voices, and bells cues to accompany their practice, with volume and mute controls for each track. Presets allow quick access to popular breathing techniques, while the interface adapts seamlessly to mobile and desktop devices. A dynamic timer and visual cues ensure an engaging and intuitive experience.
</p>
      <strong>1) Main Circle (Tap / Double Tap)</strong><br>
<img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Screenshot-2025-01-19-at-7.57.41 AM.png" alt="Relaxing soundscape image" style="width: 100px; height: 95px;"><br>
      <span style="color: cyan;">The single and double tap functions</span> give you full control over starting, pausing, and resetting the session. The phase blue needles provide a clear, interactive way to monitor your progress through each phase of breathing, while the white needles session timer tracks your total practice duration.
    </p>
   
<p>
    <strong>2) Four Small Circles for Breathing Phases</strong><br>
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Screenshot-2025-01-19-at-7.41.27 AM.png" alt="Relaxing soundscape image"><br>
    <span style="color: cyan;">Adjust the seconds for Inhale, Hold, Exhale, and Rest phases.</span> By adjusting the seconds for each phase (1 to 60 seconds), you gain full control over the pace and intensity of your breathing session, making it highly adaptable to your goals and comfort level.  
    When modified, they highlight their section on the main circle.
</p>
<p>
    <strong>3) Total Time (5th Circle)</strong><br>
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Screenshot-2025-01-19-at-7.48.57 AM.png" alt="Relaxing soundscape image" style="width: 80px; height: 80px;"><br>
    Sets the total session duration (1 to 120 minutes). A temporary needle indicates the selected value.
</p>
    <p>
      <strong>4) Preset Menu Functionality</strong><br>
<img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Screenshot-2025-01-20-at-7.28.53 PM.png" alt="Relaxing soundscape image" style="width: Auto; height: Auto;"><br>
      The Preset Menu saves time by eliminating the need to configure each phase manually for commonly used routines. However, it does not save audio preferences as part of the presets. Instead, the system always retains the last-used audio track and volume settings, ensuring your preferred sound environment stays consistent across sessions without needing to adjust it every time.
    </p>
    <p>
      <strong>5) Faders and Mute</strong><br>
<img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Screenshot-2025-01-20-at-7.29.28 PM.png" alt="Relaxing soundscape image" style="width: Auto; height: Auto;"><br>
      Control volume levels for Master, Chimes, Final Gong, Music, Environment A and Environment B.  
      Use the “🔈” button to mute/unmute each channel.
    </p>
    
  <strong>7) Chimes & Final Chime</strong><p>
<img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Screenshot-2025-01-20-at-7.30.34 PM.png" alt="Relaxing soundscape image" style="width: Auto; height: Auto;"><br> 
  <strong>Chimes:</strong> Plays at the transition between phases (e.g., from Inhale to Hold or Exhale to Rest), helping you stay aware of the flow and timing of your session without needing to constantly watch the visual indicators.<br>
  <strong>Final Chime:</strong> Marks the end of the entire session, providing a clear and calming signal that the practice is complete.
</p>

<p>
      <strong>6) Music and Environment Sounds (Hold)</strong><br>
<img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Screenshot-2025-01-22-at-9.21.17 AM.png" alt="Relaxing soundscape image" style="width: Auto; height: Auto;"><br>
      Choose music or ambient soundtracks. Enabling “Hold” keeps them playing beyond the session end, excluding chimes.
    
  </p>

<p>
      <strong>7) Guided Meditation Experience</strong><br>
At the core of Voice Training are a series of guided meditation sessions. 
Each session is led by experienced instructors who provide clear, step-by-step instructions to help you navigate through various relaxation and breathing techniques. 
These guided sessions ensure that you remain focused and engaged, allowing you to maximize the benefits of each practice without requiring prior meditation experience.
<span style="color: cyan;">Additionally, users have the option to set their own background music or soundscape, or even both simultaneously. This personalization allows each Voice Training session to better align with individual preferences, creating a more immersive and conducive environment for meditation and breathing techniques.</span>
</p>

    <p>
      <strong>8) Sticky Help Button</strong><br>
      This help button is always visible and opens this guide for quick reference.
    </p>
    <p>
      <strong>Additional Features</strong><br>
      - Adjust ambiance and music for immersive experience. <span style="color: cyan;">Pressing "Hold" will ensure the sound continues playing even after the session has ended.</span><br>
      - Control breathing phases with intuitive visuals.<br>
      - <span style="color: cyan;">Unleash your creativity by blending ambient sounds like rain, water, and wind. With the loop feature activated, your custom soundscapes will play continuously.</span>, creating immersive, endless atmospheres perfect for relaxation or focus.<br>
      - Use the session timer to personalize your relaxation practice.
    </p>
    <p>
      <em><strong>Enjoy your breathing session and achieve mindfulness! 👈</strong></em>
<img src="https://unmatrixlab.com/wp-content/uploads/2025/01/human-body-with-a-luminous-respiratory-system-1.webp" alt="Relaxing soundscape image" style="width: Auto; height: Auto;"><br> 
    </p>
<p>
Breathing is a vital process that not only sustains life but also deeply influences mental and emotional well-being. Conscious breathing techniques can regulate the nervous system, reduce stress, and improve focus. Studies show that slow, deep breathing activates the parasympathetic nervous system, promoting relaxation and decreasing anxiety. Moreover, controlled breathing can enhance oxygen supply to the brain, supporting cognitive function and emotional balance. Integrating mindful breathing into daily routines can lead to profound, positive changes in both the brain and overall health.
</p>
  </div>
</div>


<!-- ========================== ANIMACIÓN ========================== -->
<div class="unmatrix-lab-wrapper">
  <!-- Círculo grande -->
  <div class="unmatrix-lab-large-circle" id="unmatrix-lab-large-circle">
    <div id="phase-highlight"></div>
    <div class="needles-container">
      <div class="needle needle-long" id="needle-long"></div>
      <div class="needle needle-short" id="needle-short"></div>
      <div class="needle needle-temp" id="needle-temp"></div>
      <span id="temp-value">0 min</span>
      <span id="phase-highlight-value"></span>

<!-- SPINNER: Rueda de tiempo (spinner rotatorio) -->
<div id="loadingSpinner" class="loading-spinner">
  <div class="spinner"></div>
</div>

     <div id="end-session-message" class="end-session-message">
  <span>Fade Out</span>
  <div id="longFadeBarContainer" class="long-fade-bar-container">
    <div id="longFadeBarFill" class="long-fade-bar-fill"></div>
  </div>
  <!-- Nueva línea de mensaje -->
  <span class="sub-message">Double Tap Reset</span>
</div>

    </div>

    <div id="session-paused-message" class="session-paused-message">
      <span>Paused</span> <br>
      <span>Tap continue</span> <br>
      <span>Double Tap Reset</span> 
    </div>

      <!-- Mensaje de relajación -->
  <div id="session-relax-message" class="session-relax-message">
    <span>Relax to get started</span>
  </div>

  <div id="circle-swipe-message" class="circle-swipe-message">
      Swipe ↑↓
    </div>


    <div id="three-line-message" class="three-line-message">
  <span class="line">Tap to Start</span>
  <span class="line">Tap To Pause</span>
  <span class="line">Double Tap Reset</span>
</div>

    <div id="one-line-message" class="one-line-message">
  <span>Double Tap Reset</span>
</div>

 <!-- NUEVO: Mensaje Sound Hold -->
        <div id="sound-hold-message">Sounds Hold ᦠ<br>Double Tap Reset</div>
 

    <!-- ======== Animación de Aves Dentro del Círculo Grande ======== -->
    <div class="bird-container bird-container-one">
      <div class="bird bird-one"></div>
    </div>        
    <div class="bird-container bird-container-two">
      <div class="bird bird-two"></div>
    </div>  
    <div class="bird-container bird-container-three">
      <div class="bird bird-three"></div>
    </div> 
    <div class="bird-container bird-container-four">
      <div class="bird bird-four"></div>
    </div>
  </div>


  <!-- Ajustes de tiempos -->
  <div class="unmatrix-lab-small-circles">
    <div class="unmatrix-lab-small-circle">
      <input id="circle1" type="number" value="4" min="1" max="360" />
    </div>
    <div class="unmatrix-lab-small-circle">
      <input id="circle2" type="number" value="4" min="0" max="360" />
    </div>
    <div class="unmatrix-lab-small-circle">
      <input id="circle3" type="number" value="4" min="1" max="360" />
    </div>
    <div class="unmatrix-lab-small-circle">
      <input id="circle4" type="number" value="4" min="0" max="360" />
    </div>
    <div class="unmatrix-lab-small-circle">
      <input id="circle5" type="number" value="20" min="1" max="120" />
    </div>
  </div>
</div>

<!-- ======== CUSTOM ELEMENT <preset-dropdown> ======== -->
<preset-dropdown></preset-dropdown>

<!-- ======== FADER MASTER ======== -->
<div class="master-fader-container">
  <div class="slider-container-master">
    <label for="master-fader">
      Main Vol
      <button class="mute-button" data-channel="master">🔈</button>
    </label>
    <input type="range" id="master-fader" min="0" max="100" value="60">
  </div>
</div>

<!-- Contenedor para Fade Out -->
<div class="longfade-fader-container">
  <div class="slider-container-longfade">
    <label for="longFadeDuration" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
      <!-- Porcentaje independiente -->
      <div id="fadeOutProgress">
        End Fade Out: 0%
      </div>
      <!-- Tiempo en minutos independiente -->
      <div id="fadeOutLabel" >
        60 min
      </div>
    </label>
    <input type="range" id="longFadeDuration" min="1" max="240" value="60" step="1">
  </div>
</div>

<!-- ======== FADER GONG Y GONG FINAL ======== -->
<div class="gong-fader-container">
  <div class="slider-container-gong">
    <label for="gong-fader">
      Chime
      <button class="mute-button" data-channel="gong">🔈</button>
    </label>
    <input type="range" id="gong-fader" min="0" max="100" value="50">
  </div>
  <div class="slider-container-gong-final">
    <label for="gong-final-fader">
      End Chime
      <button class="mute-button" data-channel="gong_final">🔈</button>
    </label>
    <input type="range" id="gong-final-fader" min="0" max="100" value="50">
  </div>
</div>

<!-- ======== FADER AMBIENTE ======== -->
<div class="ambient-fader-container">
  <div class="slider-container-ambient">
    <label for="ambient1-fader">
      Environment A
      <button class="mute-button" data-channel="ambient1">🔈</button>
    </label>
    <input type="range" id="ambient1-fader" min="0" max="100" value="50">
  </div>
  <div class="slider-container-ambient">
    <label for="ambient2-fader">
      Environment B
      <button class="mute-button" data-channel="ambient2">🔈</button>
    </label>
    <input type="range" id="ambient2-fader" min="0" max="100" value="50">
  </div>
</div>

<!-- ======== FADER MUSIC Y VOICE TRAINING ======== -->
<div class="music-voice-training-fader-container">
  <div class="slider-container-music">
    <label for="music-fader">
      Music
      <button class="mute-button" data-channel="music">🔈</button>
    </label>
    <input type="range" id="music-fader" min="0" max="100" value="50">
  </div>
 <!-- El label con ID para detectar el clic -->
<div class="slider-container-voice-training">
  <label id="voice-training-label" for="voice-training-fader">
    Voice Training ⏰
    <button class="mute-button" data-channel="voice-training">🔈</button>
  </label>
  <input type="range" id="voice-training-fader" min="0" max="100" value="0">
</div>
</div>

<div class="eq-toggle-container">
  <!-- Toggle EQ a la izquierda -->
  <div style="display: flex; align-items: center; gap: 5px;">
    <input type="checkbox" id="toggleEQ">
    <label for="toggleEQ">Enable/Disable EQ</label>
  </div>
</div>

<!-- Contenedor para los Sliders de EQ -->
<div class="eq-fader-container" id="eqControls">
  <div class="slider-container-eqlow">
    <label for="eqLow">Low
      <span id="eqLowValue">0 dB</span>
    </label>
    <input type="range" id="eqLow" min="-10" max="10" value="0" step="1">
  </div>
  <div class="slider-container-eqmid">
    <label for="eqMid">Med
      <span id="eqMidValue">0 dB</span>
    </label>
    <input type="range" id="eqMid" min="-10" max="10" value="0" step="1">
  </div>
  <div class="slider-container-eqhigh">
    <label for="eqHigh">High
      <span id="eqHighValue">0 dB</span>
    </label>
    <input type="range" id="eqHigh" min="-10" max="10" value="0" step="1">
  </div>
</div>

<script>


document.addEventListener('DOMContentLoaded', () => {
  const helpButton = document.getElementById('help-button');
  const helpPanel = document.getElementById('help-panel');
  let isPanelVisible = false; 

  helpButton.addEventListener('click', () => {
    if (!isPanelVisible) {
      helpPanel.style.display = 'block';
      helpPanel.classList.remove('fade-out');
      helpPanel.classList.add('fade-in');
      
      // Cambiar estilo del botón para el menú abierto
      helpButton.style.transform = 'rotate(45deg)'; // Inclinar el signo de interrogación
      helpButton.style.backgroundColor = 'rgba(199, 40, 82, 0.6)'; // Cambiar el fondo a rojo
      helpButton.style.color = 'white'; // Cambiar el color del texto
      isPanelVisible = true;
    } else {
      helpPanel.classList.remove('fade-in');
      helpPanel.classList.add('fade-out');
      helpPanel.addEventListener('animationend', function handleFadeOut() {
        helpPanel.style.display = 'none';
        helpPanel.removeEventListener('animationend', handleFadeOut);
      });

      // Restaurar estilo del botón al cerrar el menú
      helpButton.style.transform = 'rotate(0deg)'; // Volver a la posición original
      helpButton.style.backgroundColor = 'rgba(85, 85, 85, 0.2)'; // Restaurar el fondo
      helpButton.style.color = 'rgba(255, 255, 255, 0.5)'; // Restaurar el color del texto
      isPanelVisible = false;
    }
  });
});
</script>

<!-- ======== CUSTOM ELEMENTS ======== -->
<gong-dropdown></gong-dropdown>
<ambient-dropdown></ambient-dropdown>
<music-voice-training-dropdown></music-voice-training-dropdown>

<!-- ======== LÓGICA DE ANIMACIÓN Y AUDIO ===================== -->
<script>

  

  /*********************************************
   * VARIABLES GLOBALES DE LOOP
   *********************************************/
  window.__ambient1LoopEnabled = false;
  window.__ambient2LoopEnabled = false;
  window.__musicLoopEnabled = false;
  window.__voiceTrainingLoopEnabled = false;

  let isPlaying = false;
  let isPaused = false;
  let isPreRoll = false;

  let startTime = 0;
  let lastUpdate = 0;
  let totalLongSec = 0;
  let totalShortSec = 0;
  let currentCycle = 0;
  let currentTotal = 0;

  const preRollDuration = 5000; 
  let preRollElapsed = 0;

  /* NUEVO: variable para la duración del Fade Out (en minutos) */
  window.__longFadeMinutes = 60; // Por defecto 60 min
  function getLongFadeDurationInSeconds() {
    return (parseInt(window.__longFadeMinutes) || 60) * 60;
  }

  /*********************************************
   * AGREGADO para PAUSA REAL de música/ambient
   *********************************************/
  let ambient1Offsets = 0;
  let ambient1StartTime = 0;
  let ambient2Offsets = 0;
  let ambient2StartTime = 0;
  let musicOffsets = 0;
  let musicStartTime = 0;
  let voiceTrainingOffsets = 0;
  let voiceTrainingStartTime = 0;

  /*********************************************
   * REFERENCIAS A ELEMENTOS
   *********************************************/
  const inputC1 = document.getElementById('circle1');
  const inputC2 = document.getElementById('circle2');
  const inputC3 = document.getElementById('circle3');
  const inputC4 = document.getElementById('circle4');
  const inputC5 = document.getElementById('circle5');

  const bigCircle = document.getElementById('unmatrix-lab-large-circle');
  const longNeedle = document.getElementById('needle-long');
  const shortNeedle = document.getElementById('needle-short');
  const tempNeedle = document.getElementById('needle-temp');
  const tempValue = document.getElementById('temp-value');
  const phaseHighlight = document.getElementById('phase-highlight');
  const phaseHighlightValue = document.getElementById('phase-highlight-value');

  let lastTap = 0;
  const doubleTapDelay = 300;
  let currentPhase = null;

  let angle1 = 0, angle2 = 0, angle3 = 0, angle4 = 0;

  /*********************************************
   * AUDIO
   *********************************************/
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();

  const gongSounds = {
    gong1: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell3x128.mp3',
    gong2: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell2x128.mp3',
    gong3: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell1x128.mp3',
    gong4: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell4x128.mp3',
    gong5: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell5x128.mp3',   
    gong6: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell11x128.mp3', 
    gong7: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Kick-Gong.mp3',  
    final_gong0: 'https://unmatrixlab.com/wp-content/uploads/2025/02/End-Voice.mp3',
    final_gong1: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell11x128.mp3',
    final_gong2: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Kick-Gong.mp3',
    final_gong3: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Bell4x128.mp3'
  };

  const specialPhaseChimeURLs = {
  inhalation: 'https://unmatrixlab.com/wp-content/uploads/2025/02/mp3-output-ttsfreedotcom.mp3',
  holdIn:     'https://unmatrixlab.com/wp-content/uploads/2025/02/mp3-output-ttsfreedotcom-2.mp3',
  exhalation: 'https://unmatrixlab.com/wp-content/uploads/2025/02/mp3-output-ttsfreedotcom-3.mp3',
  holdOut:    'https://unmatrixlab.com/wp-content/uploads/2025/02/mp3-output-ttsfreedotcom-4.mp3'
};

let specialPhaseChimeBuffers = {}; 

  const ambient1Tracks = {
    ambient1_1: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Fire.wav',
    ambient1_2: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Thunder.wav',
    ambient1_3: 'https://unmatrixlab.com/wp-content/uploads/2025/01/River2.wav',
    ambient1_4: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Birds.wav',
    ambient1_5: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Wind.wav',
    ambient1_6: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Rain-Train.wav',
    ambient1_7: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane.wav',
    ambient1_8: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane-2.wav',
    ambient1_9: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Snowstorm-1.wav',
    ambient1_10: 'https://unmatrixlab.com/wp-content/uploads/2025/01/RainLoop3.wav',
    ambient1_11: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Ocean2.wav',
    ambient1_12: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Thunder-Rain.wav',
    ambient1_13: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Bamboo-Rain.wav',
    ambient1_14: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Fountain.wav'
  };

  const ambient2Tracks = {
    ambient2_1: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Fire.wav',
    ambient2_2: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Thunder.wav',
    ambient2_3: 'https://unmatrixlab.com/wp-content/uploads/2025/01/River2.wav',
    ambient2_4: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Birds.wav',
    ambient2_5: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Wind.wav',
    ambient2_6: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Rain-Train.wav',
    ambient2_7: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane.wav',
    ambient2_8: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane-2.wav',
    ambient2_9: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Snowstorm-1.wav',
    ambient2_10: 'https://unmatrixlab.com/wp-content/uploads/2025/01/RainLoop3.wav',
    ambient2_11: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Ocean2.wav',
    ambient2_12: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Thunder-Rain.wav',
    ambient2_13: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Bamboo-Rain.wav',
    ambient2_14: 'https://unmatrixlab.com/wp-content/uploads/2025/02/Fountain.wav'
  };

  const musicVoiceTrainingTracks = {
    music_1: 'https://unmatrixlab.com/wp-content/uploads/2025/01/CitarFlauta-Binaural.mp3',
    music_2: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Pitch16.wav',
    music_3: 'https://unmatrixlab.com/wp-content/uploads/2025/01/Singer.mp3',
    music_4: 'https://unmatrixlab.com/wp-content/uploads/2025/03/Old-Film.mp3',
    voice_training_1: 'https://unmatrixlab.com/wp-content/uploads/2025/03/5-Min-Morning-Med-2.mp3',
    voice_training_2: 'https://unmatrixlab.com/wp-content/uploads/2025/03/10-Min-Guided-2.mp3',
    voice_training_3: 'https://unmatrixlab.com/wp-content/uploads/2025/03/10-Min-Guided-3.mp3',
    voice_training_4: 'https://unmatrixlab.com/wp-content/uploads/2025/03/10-Minute-Self-Forgiveness.mp3'
  };

  

  // Estados de muteo
  let isMasterMuted = false;
  let isGongMuted = false;
  let isGongFinalMuted = false;
  let isAmbient1Muted = false;
  let isAmbient2Muted = false;
  let isMusicMuted = false;
  let isVoiceTrainingMuted = false;

  const gongBuffers = {};
  let ambient1Buffers = {};
  let ambient1Source = null;
  let ambient2Buffers = {};
  let ambient2Source = null;
  let musicVoiceTrainingBuffers = {};
  let musicSource = null;
  let voiceTrainingSource = null;

  // NUEVOS nodos de ganancia, **por canal**:
  let masterGain = null;
  let gongGain = null;
  let gongFinalGain = null;
  let ambient1AutomationGain = null;
  let ambient1FaderGain = null;
  let ambient2AutomationGain = null;
  let ambient2FaderGain = null;
  let musicAutomationGain = null;
  let musicFaderGain = null;
  let voiceTrainingGain = null;

  let currentGong = 'gong1';
  let currentFinalGong = 'final_gong1';
  let currentAmbient1 = 'ambient1_1';
  let currentAmbient2 = 'ambient2_1';
  let currentMusic = 'music_1';
  let currentVoiceTraining = 'voice_training_1';

function showLoadingSpinner() {
  const spinner = document.getElementById('loadingSpinner');
  if (spinner) {
    spinner.style.display = 'block';
  }
}

function hideLoadingSpinner() {
  const spinner = document.getElementById('loadingSpinner');
  if (spinner) {
    spinner.style.display = 'none';
  }
}

  function showDobleTapMessage() {
    const msgElem = document.getElementById('end-session-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0.6'; 
  }

  function hideDobleTapMessage() {
    const msgElem = document.getElementById('end-session-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0';     
  }
  function showPausedMessage() {
    const msgElem = document.getElementById('session-paused-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0.6';
  }
  
  function hidePausedMessage() {
    const msgElem = document.getElementById('session-paused-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0';
  }

    // Función para mostrar el mensaje "Relax" con animación de pulso
    function showRelaxMessage() {
      const msgElem = document.getElementById('session-relax-message');
      if (!msgElem) return;
      msgElem.classList.add('visible');
    }

    // Función para ocultar el mensaje "Relax"
    function hideRelaxMessage() {
      const msgElem = document.getElementById('session-relax-message');
      if (!msgElem) return;
      msgElem.classList.remove('visible');
    }

  function showThreeLineMessage() {
    const msgElem = document.getElementById('three-line-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0.6';
    showSwipeMessage();
}
function hideThreeLineMessage() {
    const msgElem = document.getElementById('three-line-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0';
    hideSwipeMessage();
}
  function showOneLineMessage() {
    const msgElem = document.getElementById('one-line-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0.6';
}



function hideOneLineMessage() {
    const msgElem = document.getElementById('one-line-message');
    if (!msgElem) return;
    msgElem.style.opacity = '0'; 
}


      function showSwipeMessage() {
      const msgElem = document.getElementById('circle-swipe-message');
      if (!msgElem) return;
      msgElem.style.opacity = '0.6';
    }

    // Función para ocultar el mensaje "Swipe ↑↓"
    function hideSwipeMessage() {
      const msgElem = document.getElementById('circle-swipe-message');
      if (!msgElem) return;
      msgElem.style.opacity = '0';
    }

    function showSoundHoldMessage() {
  const msgElem = document.getElementById('sound-hold-message');
  if (msgElem) {
    msgElem.style.opacity = '0.6'; 
  }
}
function hideSoundHoldMessage() {
  const msgElem = document.getElementById('sound-hold-message');
  if (msgElem) {
    msgElem.style.opacity = '0';
  }
}

 
  function hideAllMessages() {
    hideLoadingSpinner();
    hideDobleTapMessage();
    hidePausedMessage();
  }

  function setLongFadeProgress(percent) {
    const fill = document.getElementById('longFadeBarFill');
    if (!fill) return;
    fill.style.width = percent + '%';
  }

  // === FADE IN / OUT general (master) ===
  let masterFadeGain = null;
  const fadeDuration = 1; // 1 segundo
  let fadeInTimeout = null;
  let fadeOutTimeout = null;

  function fadeIn() {
    masterFadeGain.gain.cancelScheduledValues(audioContext.currentTime);
    if (fadeOutTimeout) clearTimeout(fadeOutTimeout);

    const minGain = 0.001;
    masterFadeGain.gain.setValueAtTime(minGain, audioContext.currentTime);
    masterFadeGain.gain.exponentialRampToValueAtTime(1, audioContext.currentTime + fadeDuration);

    if (fadeInTimeout) clearTimeout(fadeInTimeout);
    fadeInTimeout = setTimeout(() => {
      if (isPlaying && !isPaused) {
        masterFadeGain.gain.setValueAtTime(1, audioContext.currentTime);
      }
    }, fadeDuration * 1000);
  }
  function fadeOut() {
    masterFadeGain.gain.cancelScheduledValues(audioContext.currentTime);
    if (fadeInTimeout) clearTimeout(fadeInTimeout);

    const minGain = 0.001;
    const currentValue = masterFadeGain.gain.value;
    masterFadeGain.gain.setValueAtTime(currentValue, audioContext.currentTime);
    masterFadeGain.gain.exponentialRampToValueAtTime(minGain, audioContext.currentTime + fadeDuration);

    if (fadeOutTimeout) clearTimeout(fadeOutTimeout);
    fadeOutTimeout = setTimeout(() => {
      if (!isPlaying || isPaused) {
        masterFadeGain.gain.setValueAtTime(minGain, audioContext.currentTime);
      }
    }, fadeDuration * 1000);
  }

  // === Fade out individual y pausar la pista ===
  const fadeOutTimeoutIDs = {
    ambient1: null,
    ambient2: null,
    music: null
  };

function longFadeOutAndStop(gainNode, sourceRef, durationSec = 60) {
  showDobleTapMessage();

  // Limpiar blink anterior si existe
  if (fadeOutBlinkInterval) {
    clearInterval(fadeOutBlinkInterval);
    fadeOutBlinkInterval = null;
  }
  // Permitir la animación de fade out
  fadeOutCancelled = false;

  // Cancelar rampas previas y obtener el valor actual
  gainNode.gain.cancelScheduledValues(audioContext.currentTime);
  const currentVal = gainNode.gain.value;
  const startTime = audioContext.currentTime;
  // Evitar cero exacto en rampa exponencial
  const minGain = 0.0001; 

  // Configurar la rampa de fade out
  gainNode.gain.setValueAtTime(currentVal, startTime);
  gainNode.gain.exponentialRampToValueAtTime(minGain, startTime + durationSec);

  // Cancelar timeout previo si existe
  if (fadeOutTimeoutIDs[sourceRef]) {
    clearTimeout(fadeOutTimeoutIDs[sourceRef]);
    fadeOutTimeoutIDs[sourceRef] = null;
  }

  // Al finalizar el fade, detener la pista y restaurar la ganancia
  const tID = setTimeout(() => {
    if (sourceRef === 'ambient1') {
      pauseAmbient1();
      showSoundHoldMessage();
    } else if (sourceRef === 'ambient2') {
      pauseAmbient2();
      showSoundHoldMessage();
    } else if (sourceRef === 'music') {
      pauseMusic();
      showSoundHoldMessage();
    }

  
    // Restablecer la ganancia del nodo de automatización a 1
    gainNode.gain.setValueAtTime(1, audioContext.currentTime);
    
    fadeOutTimeoutIDs[sourceRef] = null;
    hideDobleTapMessage();
    
    // Si ninguno de los hold está activado, reinicia la aplicación
    if (
      !window.__ambient1LoopEnabled &&
      !window.__ambient2LoopEnabled &&
      !window.__musicLoopEnabled
    ) {
      resetAll();
      // Con un pequeño retraso, limpiar los indicadores para que el siguiente tap inicie la sesión de inmediato
      setTimeout(() => {
        sessionEnded = false;
        lastTap = 0;
      }, 100);
    }
  }, durationSec * 1000);
  fadeOutTimeoutIDs[sourceRef] = tID;

  // Actualizar el progreso de la barra del fade out
  fadeOutRAF = requestAnimationFrame(() => 
    updateFadeOutProgress(startTime, durationSec, 'fadeOutProgress')
  );
}

  // Animaciones de la etiqueta Fade Out
  let fadeOutRAF = null;
  let fadeOutCancelled = false;
  function updateFadeOutProgress(startTime, durationSec, labelId) {
    if (fadeOutCancelled) return;

    const now = audioContext.currentTime;
    let fraction = (now - startTime) / durationSec;
    if (fraction > 1) fraction = 1;

    const fadeLabel = document.getElementById(labelId);
    if (!fadeLabel) return;

    const percent = Math.floor((1 - fraction) * 100);
    fadeLabel.textContent = `End Fade Out: ${percent}%`;
    setLongFadeProgress(percent);

    if (fraction < 1) {
      fadeOutRAF = requestAnimationFrame(() =>
        updateFadeOutProgress(startTime, durationSec, labelId)
      );
    } else {
      blinkFadeOutLabel(fadeLabel);
    }
  }
  let fadeOutBlinkInterval = null;
  function blinkFadeOutLabel(label) {
    if (fadeOutBlinkInterval) {
      clearInterval(fadeOutBlinkInterval);
      fadeOutBlinkInterval = null;
    }
    let count = 0;
    fadeOutBlinkInterval = setInterval(() => {
      label.style.visibility = (label.style.visibility === 'hidden') ? 'visible' : 'hidden';
      count++;
      if (count >= 12) {
        clearInterval(fadeOutBlinkInterval);
        fadeOutBlinkInterval = null;
        label.style.visibility = 'visible';
        label.textContent = 'End Fade Out: 0%';
      }
    }, 300);
  }


  // Variables para auto-mute del gong
let gongIsAutoMuted = false;

// Función para silenciar temporalmente el gong
function tempAutoMuteGong() {
  if (!gongIsAutoMuted) {
    gongAutoMuteGain.gain.value = 0; // Silenciamos la señal del gong
    gongIsAutoMuted = true;
    console.log('Gong auto-mute activado');
  }
}

// Función para restaurar el gong
function tempAutoUnmuteGong() {
  if (gongIsAutoMuted) {
    gongAutoMuteGain.gain.value = 1; // Restauramos la señal del gong
    gongIsAutoMuted = false;
    console.log('Gong auto-mute desactivado');
  }
}

  // Flags para saber si se quiere reproducir un canal antes de cargar buffers
  let areBuffersLoaded = false; 
  let isPlayingAmbient1Wanted = false;
  let isPlayingAmbient2Wanted = false;
  let isPlayingMusicWanted = false;
  let isPlayingVoiceTrainingWanted = false;

async function loadAudioFiles() {
  try {
    showLoadingSpinner();
    showThreeLineMessage();

    // Crear los nodos de ganancia (todo tu código existente)...
    masterGain = audioContext.createGain();
    gongGain = audioContext.createGain();
    gongAutoMuteGain = audioContext.createGain();
    gongFinalGain = audioContext.createGain();
    ambient1AutomationGain = audioContext.createGain();
    ambient1FaderGain = audioContext.createGain();
    ambient2AutomationGain = audioContext.createGain();
    ambient2FaderGain = audioContext.createGain();
    musicAutomationGain = audioContext.createGain();
    musicFaderGain = audioContext.createGain();
    voiceTrainingGain = audioContext.createGain();

    masterFadeGain = audioContext.createGain();
    masterFadeGain.gain.value = 0;

      // EQ de 3 bandas
      const eqLow = audioContext.createBiquadFilter();
      eqLow.type = 'peaking';
      eqLow.frequency.value = 150;
      eqLow.Q.value = 1;
      eqLow.gain.value = 0;

      const eqMid = audioContext.createBiquadFilter();
      eqMid.type = 'peaking';
      eqMid.frequency.value = 1000;
      eqMid.Q.value = 1;
      eqMid.gain.value = 0;

      const eqHigh = audioContext.createBiquadFilter();
      eqHigh.type = 'peaking';
      eqHigh.frequency.value = 10000;
      eqHigh.Q.value = 1;
      eqHigh.gain.value = 0;

      // Conexiones principales
      gongGain.connect(masterGain);
      gongFinalGain.connect(masterGain);
      ambient1FaderGain.connect(masterGain);
      ambient2FaderGain.connect(masterGain);
      musicFaderGain.connect(masterGain);
      voiceTrainingGain.connect(masterGain);

      // masterGain => eq => masterFadeGain => limiter => destination
      masterGain.connect(eqLow);
      eqLow.connect(eqMid);
      eqMid.connect(eqHigh);
      eqHigh.connect(masterFadeGain);

      const limiter = audioContext.createDynamicsCompressor();
      limiter.threshold.value = -6;
      limiter.knee.value = 3;
      limiter.ratio.value = 10;
      limiter.attack.value = 0;
      limiter.release.value = 0.25;

      masterFadeGain.connect(limiter);
      limiter.connect(audioContext.destination);

      // Configuraciones iniciales de ganancia
      masterGain.gain.value        = 0.5;
      gongGain.gain.value          = 0.4;
      gongAutoMuteGain.gain.value = 1; // Por defecto, no muteado
      gongFinalGain.gain.value     = 0.4;
      ambient1AutomationGain.gain.value = 1;
      ambient1FaderGain.gain.value      = 0.4;
      ambient2AutomationGain.gain.value = 1;
      ambient2FaderGain.gain.value      = 0.4;
      musicAutomationGain.gain.value    = 1;
      musicFaderGain.gain.value         = 0.4;
      voiceTrainingGain.gain.value      = 0.0;

      // EQ sliders
      const eqLowSlider = document.getElementById('eqLow');
      const eqMidSlider = document.getElementById('eqMid');
      const eqHighSlider = document.getElementById('eqHigh');
      const eqLowValue = document.getElementById('eqLowValue');
      const eqMidValue = document.getElementById('eqMidValue');
      const eqHighValue = document.getElementById('eqHighValue');
      const toggleEQCheckbox = document.getElementById('toggleEQ');
      const eqControlsContainer = document.getElementById('eqControls');

      function setEQ(gainLow, gainMid, gainHigh) {
        eqLow.gain.value = gainLow;
        eqMid.gain.value = gainMid;
        eqHigh.gain.value = gainHigh;
      }
      eqLowSlider.addEventListener('input', () => {
        const value = parseInt(eqLowSlider.value);
        eqLowValue.textContent = `${value} dB`;
        setEQ(value, eqMid.gain.value, eqHigh.gain.value);
        if (toggleEQCheckbox.checked) saveSettingsToLocalStorage();
      });
      eqMidSlider.addEventListener('input', () => {
        const value = parseInt(eqMidSlider.value);
        eqMidValue.textContent = `${value} dB`;
        setEQ(eqLow.gain.value, value, eqHigh.gain.value);
        if (toggleEQCheckbox.checked) saveSettingsToLocalStorage();
      });
      eqHighSlider.addEventListener('input', () => {
        const value = parseInt(eqHighSlider.value);
        eqHighValue.textContent = `${value} dB`;
        setEQ(eqLow.gain.value, eqMid.gain.value, value);
        if (toggleEQCheckbox.checked) saveSettingsToLocalStorage();
      });

      function showEQ() {
        eqControlsContainer.classList.add('visible');
        const settings = JSON.parse(localStorage.getItem('audioSettings'));
        if (settings) {
          eqLowSlider.value = settings.eqLow;
          eqMidSlider.value = settings.eqMid;
          eqHighSlider.value = settings.eqHigh;
          eqLowValue.textContent = `${settings.eqLow} dB`;
          eqMidValue.textContent = `${settings.eqMid} dB`;
          eqHighValue.textContent = `${settings.eqHigh} dB`;
          setEQ(parseInt(settings.eqLow), parseInt(settings.eqMid), parseInt(settings.eqHigh));
        }
      }
      function hideEQ() {
        eqControlsContainer.classList.remove('visible');
        setTimeout(() => {
          eqControlsContainer.style.display = 'none';
        });
        setEQ(0, 0, 0);
        eqLowSlider.value = 0;
        eqMidSlider.value = 0;
        eqHighSlider.value = 0;
        eqLowValue.textContent = '0 dB';
        eqMidValue.textContent = '0 dB';
        eqHighValue.textContent = '0 dB';
      }
      if (toggleEQCheckbox.checked) {
        eqControlsContainer.style.display = 'flex';
        setTimeout(() => { showEQ(); }, 10);
      } else {
        hideEQ();
        toggleEQCheckbox.checked = false;
      }
      toggleEQCheckbox.addEventListener('change', function() {
        if (this.checked) {
          eqControlsContainer.style.display = 'flex';
          setTimeout(() => { showEQ(); }, 10);
        } else {
          hideEQ();
          toggleEQCheckbox.checked = false;
        }
      });

      loadSettingsFromLocalStorage(); // Restablece configuraciones (faders, mute, etc.)

      // Descarga+decodifica todos los audios
      const gongPromises = Object.keys(gongSounds).map(async (key) => {
        const response = await fetch(gongSounds[key]);
        if (!response.ok) throw new Error(`Failed to load ${key}`);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        gongBuffers[key] = audioBuffer;
      });
      const ambient1Promises = Object.keys(ambient1Tracks).map(async (key) => {
        const response = await fetch(ambient1Tracks[key]);
        if (!response.ok) throw new Error(`Failed to load ${key}`);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        ambient1Buffers[key] = audioBuffer;
      });
      const ambient2Promises = Object.keys(ambient2Tracks).map(async (key) => {
        const response = await fetch(ambient2Tracks[key]);
        if (!response.ok) throw new Error(`Failed to load ${key}`);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        ambient2Buffers[key] = audioBuffer;
      });
      const musicVoiceTrainingPromises = Object.keys(musicVoiceTrainingTracks).map(async (key) => {
        const response = await fetch(musicVoiceTrainingTracks[key]);
        if (!response.ok) throw new Error(`Failed to load ${key}`);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        musicVoiceTrainingBuffers[key] = audioBuffer;
      });

         // === NUEVO (Punto 3): decodificar los 4 audios para la "4-phase Chime" ===
    const specialChimePromises = Object.keys(specialPhaseChimeURLs).map(async (phaseKey) => {
      const url = specialPhaseChimeURLs[phaseKey];
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Failed to load special chime for phase ${phaseKey}`);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      specialPhaseChimeBuffers[phaseKey] = audioBuffer;
    });


      await Promise.all([
        ...gongPromises,
        ...ambient1Promises,
        ...ambient2Promises,
        ...musicVoiceTrainingPromises,
        ...specialChimePromises
      ]);

      hideLoadingSpinner();
      areBuffersLoaded = true;

      if ((isPlaying && !isPaused) || isPreRoll) {
        fadeIn();
        
      }
      if (isPlayingAmbient1Wanted) playAmbient1();
      if (isPlayingAmbient2Wanted) playAmbient2();
      if (isPlayingMusicWanted)    playMusic();
      if (isPlayingVoiceTrainingWanted) playVoiceTraining();

    } catch (error) {
      console.error('Error al cargar los archivos de audio:', error);
      hideLoadingSpinner();
    }
  }
  window.addEventListener('DOMContentLoaded', loadAudioFiles);

  // Pequeña función para gong
function playGong() {
  if (currentGong === 'none') return;
  const buffer = gongBuffers[currentGong];
  if (!buffer) return;
  const source = audioContext.createBufferSource();
  source.buffer = buffer;
  // Conexión del nodo de auto-mute
  source.connect(gongAutoMuteGain).connect(gongGain).connect(masterGain);
  source.start(0);
  console.log(`Reproduciendo gong: ${currentGong}`);
}

function playPhaseChime(phase) {
  const buffer = specialPhaseChimeBuffers[phase];
  if (!buffer) return;
  const source = audioContext.createBufferSource();
  source.buffer = buffer;
  // Encadenar igual que en el gong normal
  source.connect(gongAutoMuteGain).connect(gongGain).connect(masterGain);
  source.start(0);
}

  function playFinalGong() {
    unhighlightAllPhases();
    if (currentFinalGong === 'none_final') return;
    const buffer = gongBuffers[currentFinalGong];
    if (!buffer) return;
    const source = audioContext.createBufferSource();
    source.buffer = buffer;
    source.connect(gongFinalGain).connect(masterGain);
    source.start(0);
  }

  // AMBIENT 1 - con nodos de automatización y fader
  function playAmbient1() {
    if (currentAmbient1 === 'ambient1_none') {
      pauseAmbient1();
      return;
    }
    if (!areBuffersLoaded) {
      isPlayingAmbient1Wanted = true;
      return;
    }
    const buffer = ambient1Buffers[currentAmbient1];
    if (!buffer) {
      isPlayingAmbient1Wanted = true;
      return;
    }
    // Cancelamos rampas previas en el nodo de automatización
    ambient1AutomationGain.gain.cancelScheduledValues(audioContext.currentTime);

    // Mute o setear valor del fader
    if (!isAmbient1Muted) {
      ambient1FaderGain.gain.setValueAtTime(document.getElementById('ambient1-fader').value / 100, audioContext.currentTime);
    } else {
      ambient1FaderGain.gain.setValueAtTime(0, audioContext.currentTime);
    }

    if (ambient1Source) {
      ambient1Source.stop();
      ambient1Source.disconnect();
      ambient1Source = null;
    }
    ambient1Source = audioContext.createBufferSource();
    ambient1Source.buffer = buffer;
    ambient1Source.loop = true;

    // Cadena: source -> automation -> fader -> master
    ambient1Source.connect(ambient1AutomationGain);
    ambient1AutomationGain.connect(ambient1FaderGain);

    ambient1StartTime = audioContext.currentTime;
    ambient1Source.start(0, ambient1Offsets);
    isPlayingAmbient1Wanted = false;
  }
  function pauseAmbient1() {
    if (ambient1Source) {
      ambient1Offsets += (audioContext.currentTime - ambient1StartTime);
      ambient1Source.stop(0);
      ambient1Source.disconnect();
      ambient1Source = null;
    }
  }

  // AMBIENT 2 - con nodos de automatización y fader
  function playAmbient2() {
    if (currentAmbient2 === 'ambient2_none') {
      pauseAmbient2();
      return;
    }
    if (!areBuffersLoaded) {
      isPlayingAmbient2Wanted = true;
      return;
    }
    const buffer = ambient2Buffers[currentAmbient2];
    if (!buffer) {
      isPlayingAmbient2Wanted = true;
      return;
    }
    ambient2AutomationGain.gain.cancelScheduledValues(audioContext.currentTime);
    if (!isAmbient2Muted) {
      ambient2FaderGain.gain.setValueAtTime(document.getElementById('ambient2-fader').value / 100, audioContext.currentTime);
    } else {
      ambient2FaderGain.gain.setValueAtTime(0, audioContext.currentTime);
    }
    if (ambient2Source) {
      ambient2Source.stop(0);
      ambient2Source.disconnect();
      ambient2Source = null;
    }
    ambient2Source = audioContext.createBufferSource();
    ambient2Source.buffer = buffer;
    ambient2Source.loop = true;

    // Cadena: source -> automation -> fader -> master
    ambient2Source.connect(ambient2AutomationGain);
    ambient2AutomationGain.connect(ambient2FaderGain);

    ambient2StartTime = audioContext.currentTime;
    ambient2Source.start(0, ambient2Offsets);
    isPlayingAmbient2Wanted = false;
  }
  function pauseAmbient2() {
    if (ambient2Source) {
      ambient2Offsets += (audioContext.currentTime - ambient2StartTime);
      ambient2Source.stop(0);
      ambient2Source.disconnect();
      ambient2Source = null;
    }
  }

  // MUSIC - con nodos de automatización y fader
  function playMusic() {
    if (currentMusic === 'music_none') {
      pauseMusic();
      return;
    }
    if (!areBuffersLoaded) {
      isPlayingMusicWanted = true;
      return;
    }
    const buffer = musicVoiceTrainingBuffers[currentMusic];
    if (!buffer) {
      isPlayingMusicWanted = true;
      return;
    }
    musicAutomationGain.gain.cancelScheduledValues(audioContext.currentTime);
    if (!isMusicMuted) {
      musicFaderGain.gain.setValueAtTime(document.getElementById('music-fader').value / 100, audioContext.currentTime);
    } else {
      musicFaderGain.gain.setValueAtTime(0, audioContext.currentTime);
    }
    if (musicSource) {
      musicSource.stop(0);
      musicSource.disconnect();
      musicSource = null;
    }
    musicSource = audioContext.createBufferSource();
    musicSource.buffer = buffer;
    musicSource.loop = true;

    // Cadena: source -> automation -> fader -> master
    musicSource.connect(musicAutomationGain);
    musicAutomationGain.connect(musicFaderGain);

    musicStartTime = audioContext.currentTime;
    musicSource.start(0, musicOffsets);
    isPlayingMusicWanted = false;
  }
  function pauseMusic() {
    if (musicSource) {
      musicOffsets += (audioContext.currentTime - musicStartTime);
      musicSource.stop(0);
      musicSource.disconnect();
      musicSource = null;
    }
  }

  // VOICE TRAINING (se mantiene con un solo nodo)
  function playVoiceTraining() {
    if (currentVoiceTraining === 'voice_training_none') {
      pauseVoiceTraining();
      return;
    }
    if (!areBuffersLoaded) {
      isPlayingVoiceTrainingWanted = true;
      return;
    }
    const buffer = musicVoiceTrainingBuffers[currentVoiceTraining];
    if (!buffer) {
      isPlayingVoiceTrainingWanted = true;
      return;
    }
    if (voiceTrainingSource) {
      voiceTrainingSource.stop(0);
      voiceTrainingSource.disconnect();
      voiceTrainingSource = null;
    }
    voiceTrainingSource = audioContext.createBufferSource();
    voiceTrainingSource.buffer = buffer;
    voiceTrainingSource.loop = window.__voiceTrainingLoopEnabled;
    voiceTrainingSource.connect(voiceTrainingGain).connect(masterGain);
    voiceTrainingStartTime = audioContext.currentTime;
    voiceTrainingSource.start(0, voiceTrainingOffsets);
    isPlayingVoiceTrainingWanted = false;
  }
  function pauseVoiceTraining() {
    if (voiceTrainingSource) {
      voiceTrainingOffsets += (audioContext.currentTime - voiceTrainingStartTime);
      voiceTrainingSource.stop(0);
      voiceTrainingSource.disconnect();
      voiceTrainingSource = null;
    }
  }

  // ====================== LÓGICA DE ANIMACIÓN ======================
  bigCircle.addEventListener('click', handleTap);
  let sessionEnded = false;  

  // Agrega esta variable global para almacenar el timeout:
let tapTimer = null;

function handleTap() {

   // Si estamos en plena animación de reset, ignoramos el tap.
  if (isResettingAnimation) {
    console.log("Ignorado tap durante el resetAll");
    return;
  }


  const now = Date.now();
  const diff = now - lastTap;
  lastTap = now;

  // Si existía un timeout pendiente para singleTapAction(), se limpia
  if (tapTimer) {
    clearTimeout(tapTimer);
    tapTimer = null;
  }

  if (!sessionEnded) {
    if (diff < doubleTapDelay) {
      // Cancelamos animación de fadeout si está corriendo
      if (fadeOutRAF) {
        cancelAnimationFrame(fadeOutRAF);
        fadeOutRAF = null;
      }
      const label = document.getElementById('fadeOutProgress');
      if (label) {
        label.textContent = 'Fade Out: 0%';
      }
      fadeOut();
      resetAll();
    } else {
      // En vez de llamar directamente a singleTapAction(),
      // lo programamos tras doubleTapDelay:
      tapTimer = setTimeout(() => {
        singleTapAction();
        tapTimer = null;
      }, doubleTapDelay / 1.6);
    }
    return;
  }

  // Si la sesión ya terminó
  if (diff < doubleTapDelay) {
    fadeOut();
    resetAll();
    sessionEnded = false;
  } else {
    console.log("La sesión ha terminado. Doble tap para iniciar nueva sesión.");
  }
}

  function singleTapAction() {
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    if (isPreRoll) {
      if (!isPaused) {
        isPaused = true;
        fadeOut();
      } else {
        isPaused = false;
        fadeIn();
        requestAnimationFrame(preRollLoop);
      }
      return;
    }
    if (!isPlaying) {
      startPreRoll();
    } else {
      if (!isPaused) {
        pauseAnimation();
        showPausedMessage();
        fadeOut();
      } else {
        resumeAnimation();
        hidePausedMessage();
        fadeIn();
      }
    }
  }

  

  function startPreRoll() {
    updateDurations();
    if (totalLongSec <= 0) totalLongSec = 1;
    if (totalShortSec <= 0) totalShortSec = 60;
    isPreRoll = true;
    isPlaying = false;
    isPaused = false;
    preRollElapsed = 0;
    currentCycle = 0;
    currentTotal = 0;
    longNeedle.style.transform = 'rotate(0deg)';
    shortNeedle.style.transform = 'rotate(0deg)';
    currentPhase = null;
    startTime = performance.now();
    lastUpdate = startTime;

    playAmbient1();
    playAmbient2();
    fadeIn();
    showRelaxMessage();
    requestAnimationFrame(preRollLoop);
    hideThreeLineMessage();
  }
  function preRollLoop(timestamp) {   
    if (!isPreRoll) return;
    hidePausedMessage();
    if (isPaused) {
      lastUpdate = timestamp;
      requestAnimationFrame(preRollLoop);
      showPausedMessage();
      return;
    }
    const delta = timestamp - lastUpdate;
    lastUpdate = timestamp;
    preRollElapsed += delta;
    const progress = Math.min(preRollElapsed / preRollDuration, 1);
    const angle = -360 * progress;
    longNeedle.style.transform = `rotate(${angle}deg)`;
    shortNeedle.style.transform = `rotate(${angle}deg)`;
    if (progress < 1) {
      requestAnimationFrame(preRollLoop);
    } else {
      isPreRoll = false;
      startAnimation();
    }
  }
  function startAnimation() {
    isPlaying = true;
    isPaused = false;
    startTime = performance.now();
    lastUpdate = startTime;
    playVoiceTraining();
    playMusic();
    requestAnimationFrame(animationLoop);
    hideRelaxMessage();
  }
  function animationLoop(timestamp) {
    if (!isPlaying || isPaused) return;
    updateDurations();
    const delta = (timestamp - lastUpdate) / 1000;
    lastUpdate = timestamp;
    currentCycle += delta;
    currentTotal += delta;
    const cyclePosition = currentCycle % totalLongSec;
    const fractionLong = cyclePosition / totalLongSec;
    const angleLong = fractionLong * 360;
    let fractionShort = currentTotal / totalShortSec;
    if (fractionShort > 1) fractionShort = 1;
    const angleShort = fractionShort * 360;
    longNeedle.style.transform = `rotate(${angleLong}deg)`;
    shortNeedle.style.transform = `rotate(${angleShort}deg)`;

    const [c1, c2, c3, c4] = getCurrentInputValues();
    let newPhase = null;
    if (cyclePosition < c1) {
      newPhase = 'inhalation';
    } else if (cyclePosition < c1 + c2) {
      newPhase = 'holdIn';
    } else if (cyclePosition < c1 + c2 + c3) {
      newPhase = 'exhalation';
    } else {
      newPhase = 'holdOut';
    }
   if (newPhase !== currentPhase) {
  currentPhase = newPhase;
  if (!isPreRoll) {
    if (currentGong === 'gong_special') {
      playPhaseChime(newPhase);
    } else {
      playGong();
    }
  }
  highlightCurrentPhase(newPhase);
}
    // Chequeo de final de la sesión
    if (currentCycle >= totalLongSec && fractionShort >= 1) {
      const aligned = Math.abs(angleLong - angleShort) < 2 ||
                      Math.abs(angleLong - angleShort - 360) < 2;
      if (aligned) {
        playFinalGong();
        isPlaying = false;
        sessionEnded = true;
        setNeedlesToZero();
        tempNeedle.style.opacity = '0';
        tempValue.style.opacity = '0';

         if ([window.__ambient1LoopEnabled, window.__ambient2LoopEnabled, window.__musicLoopEnabled].every(val => val)) {
  showSoundHoldMessage();// Los tres canales están activos
}
        // Al finalizar, fade out de x segundos si no está en loop
        if (!window.__ambient1LoopEnabled) {
          longFadeOutAndStop(ambient1AutomationGain, 'ambient1', getLongFadeDurationInSeconds());
        }
        if (!window.__ambient2LoopEnabled) {
          longFadeOutAndStop(ambient2AutomationGain, 'ambient2', getLongFadeDurationInSeconds());
        }
        if (!window.__musicLoopEnabled) {
          longFadeOutAndStop(musicAutomationGain, 'music', getLongFadeDurationInSeconds());
        }
        return;
      }
    }
    requestAnimationFrame(animationLoop);
  }

  function playPhaseChime(phase) {
  const buffer = specialPhaseChimeBuffers[phase];
  if (!buffer) return; // Si algún URL no se cargó o la fase es inexistente
  const source = audioContext.createBufferSource();
  source.buffer = buffer;
  // Usa el mismo canal de volumen del gong (gongGain) o crea otro si prefieres
  source.connect(gongAutoMuteGain).connect(gongGain).connect(masterGain);
  source.start(0);
}

function highlightCurrentPhase(phase) {
  // 1) Quita la clase .active-phase de los 4 primeros círculos
  const circles = document.querySelectorAll(
    '.unmatrix-lab-small-circles > .unmatrix-lab-small-circle'
  );

  circles.forEach(circle => circle.classList.remove('active-phase'));

  // 2) Aplica .active-phase según la fase actual
  switch (phase) {
    case 'inhalation':  // Fase 1
      circles[0].classList.add('active-phase');
      break;
    case 'holdIn':      // Fase 2
      circles[1].classList.add('active-phase');
      break;
    case 'exhalation':  // Fase 3
      circles[2].classList.add('active-phase');
      break;
    case 'holdOut':     // Fase 4
      circles[3].classList.add('active-phase');
      break;
  }
}

function unhighlightAllPhases() {
  const circles = document.querySelectorAll('.unmatrix-lab-small-circles > .unmatrix-lab-small-circle');
  circles.forEach(circle => circle.classList.remove('active-phase'));
}

  function setNeedlesToZero() {
    longNeedle.style.transform = `rotate(0deg)`;
    shortNeedle.style.transform = `rotate(0deg)`;
  }
  function pauseAnimation() {
    isPaused = true;
    setTimeout(() => {
      pauseAmbient1();
      pauseAmbient2();
      pauseMusic();
      pauseVoiceTraining();
    }, fadeDuration * 400);
  }
  function resumeAnimation() {
    isPaused = false;
    startTime = performance.now();
    lastUpdate = startTime;
    playAmbient1();
    playAmbient2();
    playMusic();
    playVoiceTraining();
    if (isPreRoll) {
      requestAnimationFrame(preRollLoop);
    } else {
      requestAnimationFrame(animationLoop);
    }
  }

let isResettingAnimation = false;

function resetAll() {
  fadeOut();
 unhighlightAllPhases();
  hideRelaxMessage();
 showThreeLineMessage();
 hideSoundHoldMessage();
  // -- Cancelar timeouts, detener fade outs, reiniciar offsets, pausar pistas, etc. --
  Object.keys(fadeOutTimeoutIDs).forEach(ref => {
    const tID = fadeOutTimeoutIDs[ref];
    if (tID) {
      clearTimeout(tID);
      fadeOutTimeoutIDs[ref] = null;
    }
      ambient1AutomationGain.gain.cancelScheduledValues(audioContext.currentTime);
  ambient2AutomationGain.gain.cancelScheduledValues(audioContext.currentTime);
  musicAutomationGain.gain.cancelScheduledValues(audioContext.currentTime);
  // Restablecer las ganancias a 1 para evitar que queden en cero
ambient1AutomationGain.gain.setValueAtTime(1, audioContext.currentTime);
ambient2AutomationGain.gain.setValueAtTime(1, audioContext.currentTime);
musicAutomationGain.gain.setValueAtTime(1, audioContext.currentTime);
  ambient1Offsets = 0;
  ambient2Offsets = 0;
  musicOffsets = 0;
  voiceTrainingOffsets = 0;
  pauseAmbient1();
  pauseAmbient2();
  pauseMusic();
  pauseVoiceTraining();
  isPlaying = false;
  isPaused = false;
  isPreRoll = false;
  currentCycle = 0;
  currentTotal = 0;
  preRollElapsed = 0;
  currentPhase = null;
  hidePausedMessage();
  });




  isResettingAnimation = true; // <-- Activamos el bloqueo de taps

  // Obtenemos el ángulo actual de cada aguja
  const startAngleLong  = getCurrentAngle(longNeedle);
  const startAngleShort = getCurrentAngle(shortNeedle);
  const duration = 1500; // Duración en milisegundos
  const startTimeReset = performance.now();

  function resetLoop(now) {
    const elapsed = now - startTimeReset;
    const prog = Math.min(elapsed / duration, 1);

    // Para la aguja larga:
    // Si el ángulo actual (módulo 360) es cercano a 0, se fuerza una vuelta completa antihoraria;
    // de lo contrario se interpola hasta 0.
    let targetAngleLong = (Math.abs(startAngleLong % 360) < 1)
                          ? startAngleLong - 360
                          : 0;
    const currentAngleLong = startAngleLong + (targetAngleLong - startAngleLong) * prog;

    // Para la aguja corta (misma lógica individual):
    let targetAngleShort = (Math.abs(startAngleShort % 360) < 1)
                           ? startAngleShort - 360
                           : 0;
    const currentAngleShort = startAngleShort + (targetAngleShort - startAngleShort) * prog;

    // Se asigna el estilo de transformación a cada aguja
    longNeedle.style.transform  = `rotate(${currentAngleLong}deg)`;
    shortNeedle.style.transform = `rotate(${currentAngleShort}deg)`;

    if (prog < 1) {
      requestAnimationFrame(resetLoop);
    } else {
      // Al finalizar, se fuerza la posición en 0 para ambas agujas
      longNeedle.style.transform  = 'rotate(0deg)';
      shortNeedle.style.transform = 'rotate(0deg)';
      isResettingAnimation = false; // <-- ¡Listo, se habilita tap de nuevo!
      // Se ocultan elementos adicionales (labels, marcadores, etc.)
      phaseHighlight.style.opacity = '0';
      phaseHighlightValue.style.opacity = '0';
      tempNeedle.style.opacity = '0';
      tempValue.style.opacity = '0';
    }
  }

  requestAnimationFrame(resetLoop);

  // -- Se oculta el mensaje de Fade Out y se cancelan animaciones pendientes --
  hideDobleTapMessage();
  fadeOutCancelled = true;
  if (fadeOutRAF) cancelAnimationFrame(fadeOutRAF);
  fadeOutRAF = null;
  if (fadeOutBlinkInterval) {
    clearInterval(fadeOutBlinkInterval);
    fadeOutBlinkInterval = null;
  }
  const label = document.getElementById('fadeOutProgress');
  if (label) {
    label.style.visibility = 'visible';
    label.textContent = 'Fade Out: 0%';
  }
}
  function getCurrentAngle(needle) {
    const st = window.getComputedStyle(needle, null);
    const tr = st.getPropertyValue('transform');
    if (tr === 'none') return 0;
    const values = tr.split('(')[1].split(')')[0].split(',');
    const a = parseFloat(values[0]);
    const b = parseFloat(values[1]);
    let angle = Math.round(Math.atan2(b, a) * (180 / Math.PI));
    if (angle < 0) angle += 360;
    return angle;
  }
  function updateDurations() {
    const c1 = parseInt(inputC1.value, 10) || 0;
    const c2 = parseInt(inputC2.value, 10) || 0;
    const c3 = parseInt(inputC3.value, 10) || 0;
    const c4 = parseInt(inputC4.value, 10) || 0;
    const c5 = parseInt(inputC5.value, 10) || 1;
    totalLongSec = c1 + c2 + c3 + c4;
    totalShortSec = c5 * 60;
    if (totalLongSec <= 0) totalLongSec = 1;
    if (totalShortSec <= 0) totalShortSec = 60;
    updateLargeCircle();
  }
  function getCurrentInputValues() {
    return [
      parseInt(inputC1.value, 10) || 1,
      parseInt(inputC2.value, 10) || 0,
      parseInt(inputC3.value, 10) || 1,
      parseInt(inputC4.value, 10) || 0,
      parseInt(inputC5.value, 10) || 5
    ];
  }

  function hideTempNeedleInstant() {
    if (tempNeedleTimeout) {
      clearTimeout(tempNeedleTimeout);
      tempNeedleTimeout = null;
    }
    tempNeedle.style.opacity = '0';
    tempValue.style.opacity = '0';
    tempNeedle.style.transform = 'rotate(0deg)'; // Resetea la aguja a 0 grados
  }

  const circles = document.querySelectorAll('.unmatrix-lab-small-circle');
  circles.forEach(circle => {
    let startY = 0;
    const input = circle.querySelector('input');

    function disableInputKeyboardOnMobile() {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      if (isMobile) {
        document.querySelectorAll('input').forEach(input => {
          input.setAttribute('readonly', 'readonly');
        });
      }
    }
    disableInputKeyboardOnMobile();

    circle.addEventListener('touchstart', e => {
      startY = e.touches[0].clientY;
    });
    circle.addEventListener('touchmove', e => {
      const currentY = e.touches[0].clientY;
      const deltaY = startY - currentY;
      if (deltaY > 20) {
        incrementValue(input);
        input.dispatchEvent(new Event('input'));
        startY = currentY;
      } else if (deltaY < -20) {
        decrementValue(input);
        input.dispatchEvent(new Event('input'));
        startY = currentY;
      }
      updateLargeCircle();
      emitInputChangeEvent();
      if (input.id !== 'circle5') {
        const phaseNumber = parseInt(input.id.replace('circle',''),10);
        const value = parseInt(input.value,10) || 0;
        highlightPhaseSegment(phaseNumber, value);
      }
    });
    circle.addEventListener('touchend', () => {});
    circle.addEventListener('mousedown', () => {});
    circle.addEventListener('mouseup', () => {});
    input.addEventListener('change', () => {
      let value = parseInt(input.value, 10) || 0;
      const min = parseInt(input.getAttribute('min'), 10);
      const max = parseInt(input.getAttribute('max'), 10);
      if (value < min) value = min;
      if (value > max) value = max;
      input.value = value;
      updateLargeCircle();
      emitInputChangeEvent();
      saveSettingsToLocalStorage();
      if (input.id !== 'circle5') {
        const phaseNumber = parseInt(input.id.replace('circle',''),10);
        const val = parseInt(input.value,10) || 0;
        highlightPhaseSegment(phaseNumber, val);
      }
    });
    input.addEventListener('input', () => {
      updateLargeCircle();
      emitInputChangeEvent();
      saveSettingsToLocalStorage();
      if (input.id !== 'circle5') {
        const phaseNumber = parseInt(input.id.replace('circle',''),10);
        const val = parseInt(input.value,10) || 0;
        highlightPhaseSegment(phaseNumber, val);
      }
    });
  });
  function incrementValue(input) {
    const max = parseInt(input.getAttribute('max'),10);
    let value = parseInt(input.value,10)||0;
    if (value<max) input.value = value+1;
  }
  function decrementValue(input) {
    const min = parseInt(input.getAttribute('min'),10);
    let value = parseInt(input.value,10)||0;
    if (value>min) input.value = value-1;
  }
  function updateLargeCircle() {
    const c1 = parseInt(inputC1.value,10)||0;
    const c2 = parseInt(inputC2.value,10)||0;
    const c3 = parseInt(inputC3.value,10)||0;
    const c4 = parseInt(inputC4.value,10)||0;
    const total = c1+c2+c3+c4;
    if(total===0) {
      bigCircle.style.background='conic-gradient(#555 0deg,#555 360deg)';
      return;
    }
    angle1=(c1/total)*360;
    angle2=angle1+(c2/total)*360;
    angle3=angle2+(c3/total)*360;
    angle4=angle3+(c4/total)*360;
    bigCircle.style.background=`
      conic-gradient(
        var(--circle-color-light1) 0deg ${angle1}deg,
        var(--circle-color-light2) ${angle1}deg ${angle2}deg,
        var(--circle-color-light3) ${angle2}deg ${angle3}deg,
        var(--circle-color-light4) ${angle3}deg ${angle4}deg,
        var(--my-extra-celeste) ${angle4}deg 360deg
      )
    `;
  }
  function emitInputChangeEvent(){
    const event=new CustomEvent('inputChange',{
      detail:{ values:getCurrentInputValues()}
    });
    document.dispatchEvent(event);
  }

  // Aguja temporal
  let tempNeedleTimeout;
  function showTempNeedle(value, hideAfterMs=1500){
    phaseHighlight.style.opacity='0';
    phaseHighlightValue.style.opacity='0';
    if(tempNeedleTimeout){
      clearTimeout(tempNeedleTimeout);
      tempNeedleTimeout=null;
    }
    const maxMinutes=60;
    const angle=(value/maxMinutes)*360;
    tempNeedle.style.transform=`rotate(${angle}deg)`;
    tempNeedle.style.opacity='1';
    tempValue.textContent=`Time: ${value} min`;
    tempValue.style.opacity='1';
    if(hideAfterMs>0){
      tempNeedleTimeout=setTimeout(()=>{
        tempNeedle.style.opacity='0';
        tempValue.style.opacity='0';
        //tempNeedle.style.transform = 'rotate(0deg)';
        tempNeedleTimeout=null;
      },hideAfterMs);
    }
  }

  inputC5.addEventListener('input',()=>{
    const value=parseInt(inputC5.value,10)||0;
    showTempNeedle(value,1000);
  });

  const highlightColors=[
    'rgba(10,10,50,0.5)',
    'rgba(19,120,122,0.5)',
    'rgba(165,171,100,0.5)',
    'rgba(222,117,100,0.5)'
  ];
  let phaseHighlightTimeout=null;
  function highlightPhaseSegment(phaseNumber,value){
    hideTempNeedleInstant();
    let startAngle=0;
    let endAngle=0;
    switch(phaseNumber){
      case 1:startAngle=0;endAngle=angle1;break;
      case 2:startAngle=angle1;endAngle=angle2;break;
      case 3:startAngle=angle2;endAngle=angle3;break;
      case 4:startAngle=angle3;endAngle=angle4;break;
      default:return;
    }
    if(endAngle-startAngle<5){
      endAngle=startAngle+5;
    }
    const highlightColor=highlightColors[phaseNumber-1];
    const highlightGradient=`
      conic-gradient(
        rgba(0,0,0,0) 0deg ${startAngle-20}deg,
        ${highlightColor} ${startAngle}deg ${endAngle}deg,
        rgba(0,0,0,0) ${endAngle+15}deg 360deg
      )
    `;
    phaseHighlight.style.background=highlightGradient;
    phaseHighlight.style.opacity='1';
    switch(phaseNumber){
      case 1:phaseHighlightValue.textContent=`Inhalation: ${value}s`;break;
      case 2:phaseHighlightValue.textContent=`Retention In: ${value}s`;break;
      case 3:phaseHighlightValue.textContent=`Exhalation: ${value}s`;break;
      case 4:phaseHighlightValue.textContent=`Retention Out: ${value}s`;break;
    }
    phaseHighlightValue.style.opacity='1';
    if(phaseHighlightTimeout) clearTimeout(phaseHighlightTimeout);
    phaseHighlightTimeout=setTimeout(()=>{
      phaseHighlight.style.opacity='0';
      phaseHighlightValue.style.opacity='0';
      phaseHighlightTimeout=null;
    },1500);
  }

  function formatTime(minutes) {
    const hrs = Math.floor(minutes / 60);
    const mins = minutes % 60;
    if (hrs > 0) {
      return `${hrs}h ${mins}min`;
    } else {
      return `${mins} min`;
    }
  }
  document.addEventListener('DOMContentLoaded', () => {
    const longFadeSlider = document.getElementById('longFadeDuration');
    const fadeOutLabel   = document.getElementById('fadeOutLabel');

    longFadeSlider.addEventListener('input', () => {
      const val = parseInt(longFadeSlider.value) || 60;
      window.__longFadeMinutes = val;
      fadeOutLabel.textContent = formatTime(val);
      saveSettingsToLocalStorage();
    });
  });


// Declara la variable en un ámbito accesible (global o del módulo)
let presetNeedleTimeout;
  
  // Guardado/Carga de presets de respiración (manejado por <preset-dropdown>)
  const presetDropdown=document.querySelector('preset-dropdown');

presetDropdown.addEventListener('presetChange', (e) => {
  const values = e.detail.values;
  const c5 = values[4];
  hideTempNeedleInstant();
  
  // Cancela el timeout anterior si existe
  if (presetNeedleTimeout) {
    clearTimeout(presetNeedleTimeout);
    presetNeedleTimeout = null;
  }
  
  let delay = 0;
  if (values[0] > 0) delay += 1500;
  if (values[1] > 0) delay += 1500;
  if (values[2] > 0) delay += 1500;
  if (values[3] > 0) delay += 1500;
  
  // Programa el timeout para mostrar la aguja
  presetNeedleTimeout = setTimeout(() => {
    showTempNeedle(c5, 0);
  }, delay);
});

  // ====================== LOCAL STORAGE =========================
  function saveSettingsToLocalStorage(){
    try{
      const circle1Value=inputC1.value;
      const circle2Value=inputC2.value;
      const circle3Value=inputC3.value;
      const circle4Value=inputC4.value;
      const circle5Value=inputC5.value;
      const masterFaderValue=document.getElementById('master-fader').value;
      const gongFaderValue=document.getElementById('gong-fader').value;
      const gongFinalFaderValue=document.getElementById('gong-final-fader').value;
      const ambient1FaderValue=document.getElementById('ambient1-fader').value;
      const ambient2FaderValue=document.getElementById('ambient2-fader').value;
      const musicFaderValue=document.getElementById('music-fader').value;
      const voiceTrainingFaderValue=document.getElementById('voice-training-fader').value;

      const masterMuted = (masterGain.gain.value===0);
      const gongMuted = (gongGain.gain.value===0);
      const gongFinalMuted = (gongFinalGain.gain.value===0);
      const ambient1Muted = (ambient1FaderGain.gain.value===0);
      const ambient2Muted = (ambient2FaderGain.gain.value===0);
      const musicMuted = (musicFaderGain.gain.value===0);
      const voiceTrainingMuted = (voiceTrainingGain.gain.value===0);

      const gongSelect = currentGong;
      const gongFinalSelect = currentFinalGong;
      const ambient1Select = currentAmbient1;
      const ambient2Select = currentAmbient2;
      const musicSelect = currentMusic;
      const voiceTrainingSelect = currentVoiceTraining;

      const ambient1Loop = window.__ambient1LoopEnabled;
      const ambient2Loop = window.__ambient2LoopEnabled;
      const musicLoop = window.__musicLoopEnabled;
      const voiceTrainingLoop = window.__voiceTrainingLoopEnabled;
      const breathingSelectedPreset = localStorage.getItem('breathingSelectedPreset');

      const longFadeValue = document.getElementById('longFadeDuration').value;

      const data={
        circle1Value,
        circle2Value,
        circle3Value,
        circle4Value,
        circle5Value,
        masterFaderValue,
        gongFaderValue,
        gongFinalFaderValue,
        ambient1FaderValue,
        ambient2FaderValue,
        musicFaderValue,
        voiceTrainingFaderValue,
        masterMuted,
        gongMuted,
        gongFinalMuted,
        ambient1Muted,
        ambient2Muted,
        musicMuted,
        voiceTrainingMuted,
        gongSelect,
        gongFinalSelect,
        ambient1Select,
        ambient2Select,
        musicSelect,
        voiceTrainingSelect,
        ambient1Loop,
        ambient2Loop,
        musicLoop,
        voiceTrainingLoop,
        breathingSelectedPreset,
        longFadeValue
      };
      localStorage.setItem('breathingAppCache',JSON.stringify(data));
    }catch(e){
      console.error('Error guardando en localStorage:',e);
    }
  }
  function loadSettingsFromLocalStorage(){
    try{
      const saved=localStorage.getItem('breathingAppCache');
      if(!saved)return;
      const data=JSON.parse(saved);

      if(data.masterFaderValue){
        const normalizedValue=data.masterFaderValue/100;
        const logValue=Math.pow(normalizedValue,2);
        document.getElementById('master-fader').value=data.masterFaderValue;
        masterGain.gain.value=logValue;
      }
      if(data.longFadeValue){
        const fadeSlider = document.getElementById('longFadeDuration');
        fadeSlider.value = data.longFadeValue;
        window.__longFadeMinutes = parseInt(data.longFadeValue,10);
        const fadeOutLabel = document.getElementById('fadeOutLabel');
        if (fadeOutLabel) {
          fadeOutLabel.textContent = formatTime(parseInt(data.longFadeValue,10));
        }
      }
      if(data.gongFaderValue){
        document.getElementById('gong-fader').value=data.gongFaderValue;
        gongGain.gain.value=data.gongFaderValue/100;
      }
      if(data.gongFinalFaderValue){
        document.getElementById('gong-final-fader').value=data.gongFinalFaderValue;
        gongFinalGain.gain.value=data.gongFinalFaderValue/100;
      }
      if(data.ambient1FaderValue){
        document.getElementById('ambient1-fader').value=data.ambient1FaderValue;
        ambient1FaderGain.gain.value = data.ambient1FaderValue / 100;
      }
      if(data.ambient2FaderValue){
        document.getElementById('ambient2-fader').value=data.ambient2FaderValue;
        ambient2FaderGain.gain.value = data.ambient2FaderValue / 100;
      }
      if(data.musicFaderValue){
        document.getElementById('music-fader').value=data.musicFaderValue;
        musicFaderGain.gain.value = data.musicFaderValue / 100;
      }
      if(data.voiceTrainingFaderValue){
        document.getElementById('voice-training-fader').value=data.voiceTrainingFaderValue;
        voiceTrainingGain.gain.value = data.voiceTrainingFaderValue / 100;
      }

      const muteButtons=document.querySelectorAll('.mute-button');
      muteButtons.forEach(button=>{
        const channel=button.getAttribute('data-channel');
        let isMuted=false;
        switch(channel){
          case 'master': isMuted=data.masterMuted;break;
          case 'gong': isMuted=data.gongMuted;break;
          case 'gong_final': isMuted=data.gongFinalMuted;break;
          case 'ambient1': isMuted=data.ambient1Muted;break;
          case 'ambient2': isMuted=data.ambient2Muted;break;
          case 'music': isMuted=data.musicMuted;break;
          case 'voice-training': isMuted=data.voiceTrainingMuted;break;
        }
        if(isMuted){
          toggleMute(channel,button,true);
        }
      });
      if(data.gongSelect) currentGong=data.gongSelect;
      if(data.gongFinalSelect) currentFinalGong=data.gongFinalSelect;
      if(data.ambient1Select) currentAmbient1=data.ambient1Select;
      if(data.ambient2Select) currentAmbient2=data.ambient2Select;
      if(data.musicSelect) currentMusic=data.musicSelect;
      if(data.voiceTrainingSelect) currentVoiceTraining=data.voiceTrainingSelect;

      const gongDrop=document.querySelector('gong-dropdown');
      if(gongDrop){
        if(data.gongSelect) gongDrop.selectGong(data.gongSelect);
        if(data.gongFinalSelect) gongDrop.selectFinalGong(data.gongFinalSelect);
      }
      const ambientDrop=document.querySelector('ambient-dropdown');
      if(ambientDrop){
        if(data.ambient1Select) ambientDrop.selectAmbient1(data.ambient1Select);
        if(data.ambient2Select) ambientDrop.selectAmbient2(data.ambient2Select);
      }
      const musicVoiceTrainingDrop=document.querySelector('music-voice-training-dropdown');
      if(musicVoiceTrainingDrop){
        if(data.musicSelect) musicVoiceTrainingDrop.selectMusic(data.musicSelect);
        if(data.voiceTrainingSelect) musicVoiceTrainingDrop.selectVoiceTraining(data.voiceTrainingSelect);
      }
      if(typeof data.ambient1Loop==='boolean'){
        window.__ambient1LoopEnabled=data.ambient1Loop;
        const ambientDropdownElem=document.querySelector('ambient-dropdown');
        if(ambientDropdownElem){
          const amb1LoopCheck=ambientDropdownElem.shadowRoot.querySelector('#ambient1-loop-checkbox');
          if(amb1LoopCheck) amb1LoopCheck.checked=data.ambient1Loop;
        }
      }
      if(typeof data.ambient2Loop==='boolean'){
        window.__ambient2LoopEnabled=data.ambient2Loop;
        const ambientDropdownElem=document.querySelector('ambient-dropdown');
        if(ambientDropdownElem){
          const amb2LoopCheck=ambientDropdownElem.shadowRoot.querySelector('#ambient2-loop-checkbox');
          if(amb2LoopCheck) amb2LoopCheck.checked=data.ambient2Loop;
        }
      }
      if(typeof data.musicLoop==='boolean'){
        window.__musicLoopEnabled=data.musicLoop;
        const musicVoiceTrainingDropdownElem=document.querySelector('music-voice-training-dropdown');
        if(musicVoiceTrainingDropdownElem){
          const musicLoopCheck=musicVoiceTrainingDropdownElem.shadowRoot.querySelector('#music-loop-checkbox');
          if(musicLoopCheck) musicLoopCheck.checked=data.musicLoop;
        }
      }
      if(typeof data.voiceTrainingLoop==='boolean'){
        window.__voiceTrainingLoopEnabled=data.voiceTrainingLoop;
        const musicVoiceTrainingDropdownElem=document.querySelector('music-voice-training-dropdown');
        if(musicVoiceTrainingDropdownElem){
          const vtLoopCheck=musicVoiceTrainingDropdownElem.shadowRoot.querySelector('#voice-training-loop-checkbox');
          if(vtLoopCheck) vtLoopCheck.checked=data.voiceTrainingLoop;
        }
      }
      if(data.breathingSelectedPreset){
        const presetDropdown=document.querySelector('preset-dropdown');
        if(presetDropdown){
          presetDropdown.selectPreset(data.breathingSelectedPreset,false);
        }
      }
      emitInputChangeEvent();
    }catch(e){
      console.error('Error restaurando desde localStorage:',e);
    }
  }
</script>

 <!-- ======== CUSTOM ELEMENT <preset-dropdown> ======== -->
<script>
  window.__CURRENT_OPEN_DROPDOWN__ = null;

  // Función para generar IDs únicos para los presets
function generateUniqueId() {
  const id = 'preset-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
  console.log("Nuevo preset ID generado:", id);
  return id;
}

  class PresetDropdown extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      const template = document.createElement('template');
      template.innerHTML = `
        <style>
          :host {
            display: block;
            width: 100%;
            margin: 0 auto;
            font-family: Arial, sans-serif;
            box-sizing: border-box;
          }
          .dropdown {
            position: relative;
            text-align: center;
            width: 100%;
           
          }
          .dropdown-button {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            text-align: left;
            border: 1px solid #000;
            border-radius: 20px 20px 4px 4px;
            cursor: pointer;
            background-color: #2e3742;
            color: #00C6FF;
             font-weight: 600; /* O 200, 300, etc. */
            display: flex;
            align-items: center;
            justify-content: space-between;
            
             
          }
          .dropdown-button:hover {
          /*  background-color: #3e4a4c;*/
          }
          
          .dropdown-button::after {
          color: #000000;
            content: '▼';
            
            margin-left: 10px;
          }
          .dropdown-content {
            position: relative;
              max-height: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-height 0.3s ease, opacity 0.3s ease;
           
            border: 4px solid #000;
            border-radius: 4px 4px 8px 8px;
            box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
            padding: 10px;
            box-sizing: border-box;
            background: radial-gradient(circle, var(--menu-bg-1, #1a3a47), var(--menu-bg-2, #050c12));
            box-shadow: 0px 1px 3px rgba(255, 255, 255, 0.5);
            color: var(--label-color, #00bcd4);
           
          }
          .dropdown-content.show {
             overflow-y: auto;
              max-height: 400px;  /* Ajusta este valor según el contenido */
  opacity: 1;
          }
          .dropdown-item {
            display: flex;
            align-items: center;
            padding: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-top: 1px solid #69828a;
            position: relative;
          }
          .dropdown-item:hover {
           /* background-color: #304245;*/
          }
          .dropdown-item:first-child {
            border-top: none;
          }
          .indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: transparent;
            border: 1px solid #ccc;
            margin-right: 10px;
            transition: background-color 0.1s;
          }
          .dropdown-item.selected .indicator {
            background-color: #35cae8;
            border-color: #18c912;
          }
          .button-group {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
          }
          .button {
            flex: 1;
            padding: 10px;
            font-size: 14px;
            text-align: center;
            border: 1px solid #69828a;
            border-radius: 4px;
            background-color: #2b3633;
            color: #ffcc00 !important;
            cursor: pointer;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          .button:hover {
           /* background-color: #304245;*/
          }
          .dropdown-separator {
            border-top: 2px solid #ccc;
            margin: 1px 0;
          }
          strong {
            display: block;
            margin: 10px 0 5px 0;
            color: #ffcc00;
          }
          /* Nuevos estilos para el recuadro explicativo */
.preset-info {
  margin-left: 30px;
  margin-top: -5px;
  padding-bottom: 3px;
  border: 0px solid #ccc;
  text-align: left;
  font-size: 13px;
  color: #d6f1ff;
}
.preset-info p {
  margin: 0px 0;
}


        </style>
        <div class="dropdown">
          <button class="dropdown-button">Seleccionar Preset</button>
          <div class="dropdown-content">
          <theme-selector></theme-selector>
            <div class="button-group">
              <button class="button" id="save-preset-button">💾 Save</button>
              <button class="button" id="rename-preset-button">✏️ Rename</button>
              <button class="button" id="delete-preset-button">🗑️ Delete</button>
            </div>
            <div class="preset-list"></div>
          </div>
        </div>
      `;
      this.shadowRoot.appendChild(template.content.cloneNode(true));
    }

   connectedCallback() {
  this.dropdownButton = this.shadowRoot.querySelector('.dropdown-button');
  this.dropdownContent = this.shadowRoot.querySelector('.dropdown-content');
  this.presetListContainer = this.shadowRoot.querySelector('.preset-list');
  this.saveButton = this.shadowRoot.querySelector('#save-preset-button');
  this.renameButton = this.shadowRoot.querySelector('#rename-preset-button');
  this.deleteButton = this.shadowRoot.querySelector('#delete-preset-button');

  // Carga la lista de presets (factory + user)
  this.loadPresets();

  // Leemos qué preset se guardó previamente en localStorage.
  const savedPresetId = localStorage.getItem('breathingSelectedPreset');
  if (savedPresetId && savedPresetId !== 'custom' && this.presets.some(p => p.id === savedPresetId)) {
    const matchedPreset = this.presets.find(p => p.id === savedPresetId);
    if (matchedPreset) {
      // Obtenemos los valores actuales (ya cargados por loadSettingsFromLocalStorage)
      const currentC1 = parseInt(document.getElementById('circle1').value, 10) || 0;
      const currentC2 = parseInt(document.getElementById('circle2').value, 10) || 0;
      const currentC3 = parseInt(document.getElementById('circle3').value, 10) || 0;
      const currentC4 = parseInt(document.getElementById('circle4').value, 10) || 0;
      const currentC5 = parseInt(document.getElementById('circle5').value, 10) || 5;
      
      // Comparamos con los valores del preset guardado
      const [p1, p2, p3, p4, p5] = matchedPreset.values;
      const isSame = (p1 === currentC1 &&
                      p2 === currentC2 &&
                      p3 === currentC3 &&
                      p4 === currentC4 &&
                      p5 === currentC5);
      if (isSame) {
        // Si coinciden, se selecciona el preset (lo que actualizará el botón y marcará la opción)
        this.selectPreset(savedPresetId, false);
      } else {
        // Si no coinciden, simplemente forzamos un update del botón para mostrar "Custom - …"
        // Sin actualizar localStorage; es decir, la memoria conserva el último preset elegido.
        emitInputChangeEvent();
      }
    }
  } else if (this.presets.length > 0) {
    // Opcional: si no hay un preset guardado válido, por defecto se selecciona el primero.
    const defaultPreset = this.presets[0];
    this.selectPreset(defaultPreset.id, false);
  } else {
    this.dropdownButton.textContent = 'Select Preset';
  }

  // Listeners para abrir/cerrar el menú
 this.dropdownButton.addEventListener('click', (e) => {
  e.stopPropagation();
  if (this.dropdownContent.classList.contains('show')) {
    // Al colapsar el menú, detenemos el preview activo.
    stopCurrentPreview();
    this.dropdownContent.classList.remove('show');
    if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
      window.__CURRENT_OPEN_DROPDOWN__ = null;
    }
  } else {
    this.closeAllOthers();
    this.dropdownContent.classList.add('show');
    window.__CURRENT_OPEN_DROPDOWN__ = this;
  }
});
  this.dropdownContent.addEventListener('click', (e) => e.stopPropagation());
  document.addEventListener('click', (e) => {
    if (!this.shadowRoot.contains(e.target)) {
      this.closeDropdown();
    }
  });

  // Listeners para los botones Save, Rename y Delete
  this.saveButton.addEventListener('click', () => this.savePreset());
  this.renameButton.addEventListener('click', () => this.renamePreset());
  this.deleteButton.addEventListener('click', () => this.deletePreset());

  // Cada vez que cambien los valores (c1..c5) se llama a updateDropdownButton para actualizar el botón.
  document.addEventListener('inputChange', (e) => {
    this.updateDropdownButton(e.detail.values);
  });
}

    

    closeDropdown() {
      stopCurrentPreview();
      this.dropdownContent.classList.remove('show');
      if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      }
    }

    closeAllOthers() {
      stopCurrentPreview();
      if (window.__CURRENT_OPEN_DROPDOWN__ && window.__CURRENT_OPEN_DROPDOWN__ !== this) {
        if (window.__CURRENT_OPEN_DROPDOWN__.closeDropdown) {
          window.__CURRENT_OPEN_DROPDOWN__.closeDropdown();
        }
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      }
    }

    

    loadPresets() {
      const storedUserPresets = JSON.parse(localStorage.getItem('breathingUserPresets')) || [];
     const factoryPresets = [
  { id: 'preset1', name: 'UnmatriXLab - 4-0-4-7-5 ∱', values: [4, 0, 4, 7, 5], isFactory: true, description: 'Experimental breathing pattern for creative and unique experiences.' },
  { id: 'preset2', name: 'Pursed-Lip Breathing - 4-0-8-0-8 ∱', values: [4, 0, 8, 0, 8], isFactory: true, description: 'Exhale slowly through pursed lips for better oxygen exchange.' },
  { id: 'preset3', name: 'Alternate Nostril Breathing - 4-0-6-0-12 ∱', values: [4, 0, 6, 0, 12], isFactory: true, description: 'Alternate nostril breathing balances mind and body.' },
  { id: 'preset4', name: 'Resonant Breathing - 5-0-5-0-15 ∱', values: [5, 0, 5, 0, 15], isFactory: true, description: 'Steady breathing pattern to improve heart rate variability.' },
  { id: 'preset5', name: 'Kapalabhati - 1-0-1-0-1 ∱', values: [1, 0, 1, 0, 1], isFactory: true, description: 'Quick forceful exhales to energize and clear the mind.' },
  { id: 'preset6', name: '4-7-8 Breathing - 4-7-8-0-10 ∱', values: [4, 7, 8, 0, 10], isFactory: true, description: 'Inhale, hold, exhale with controlled timing for deep relaxation.' },
  { id: 'preset7', name: 'Equal Breathing - 6-0-6-0-20 ∱', values: [6, 0, 6, 0, 20], isFactory: true, description: 'Equal duration of inhaling and exhaling promotes calm.' },
  { id: 'preset8', name: 'Ujjayi Breathing - 5-0-5-0-18 ∱', values: [5, 0, 5, 0, 18], isFactory: true, description: 'Slight throat constriction produces soothing ocean-like sounds.' },
  { id: 'preset9', name: 'Slow Rhythmic Breathing - 6-2-8-0-15 ∱', values: [6, 2, 8, 0, 15], isFactory: true, description: 'Slow, rhythmic breathing technique reduces stress effectively.' },
  { id: 'preset10', name: 'Fast Relaxation Breathing - 3-0-3-0-6 ∱', values: [3, 0, 3, 0, 6], isFactory: true, description: 'Rapid cycles of breathing for immediate relaxation and energy boost.' },
  { id: 'preset11', name: 'Box Breathing - 4-4-4-4-10 ∱', values: [4, 4, 4, 4, 10], isFactory: true, description: 'Inhale, hold, exhale, hold. Promotes calm focus.' }
];

      this.presets = [...factoryPresets, ...storedUserPresets].slice(0, 99);
      this.updateDropdownItems();
    }

    updateDropdownItems() {
      this.presetListContainer.innerHTML = '';
      this.presets.forEach(preset => {
        const item = document.createElement('div');
        item.classList.add('dropdown-item');
        item.dataset.value = preset.id;
        const indicator = document.createElement('div');
        indicator.classList.add('indicator');
        item.appendChild(indicator);
        const name = document.createElement('span');
        name.textContent = preset.name;
        item.appendChild(name);

        item.addEventListener('click', () => {
          this.selectPreset(preset.id, true);
          this.dispatchEvent(new CustomEvent('presetChange', {
            detail: { values: preset.values }
          }));
        });

        this.presetListContainer.appendChild(item);
      });
    }

 updateDescriptionBox(preset) {
  // Si no existe, se crea el contenedor para la descripción
  if (!this.descriptionBox) {
    this.descriptionBox = document.createElement('div');
    this.descriptionBox.classList.add('preset-info');
  }
  // Si es un preset de fábrica y tiene descripción, se usa esa descripción
  if (preset.isFactory && preset.description) {
    this.descriptionBox.innerHTML = `<p>${preset.description}</p>`;
  } else {
    // Array con las frases sugeridas para presets de usuario
    const phrases = [
      "Breathe deeply, live fully.",
      "Calm mind, deep breath.",
      "Inhale peace, exhale stress.",
      "Deep breaths, clear mind.",
      "Breathe, relax, feel alive.",
      "Pause, breathe, find balance.",
      "Inhale calm, exhale chaos.",
      "Breathe slow, feel strong.",
      "Deep breath, fresh start.",
      "Mindful breath, peaceful soul.",
      "Exhale doubt, inhale courage.",
      "Breathe in strength, out fear.",
      "Stillness begins with breath.",
      "Inhale deeply, exhale gently.",
      "Breathe light, release darkness.",
      "Find peace through breath.",
      "Breathe fully, live freely.",
      "Centered mind, steady breath.",
      "Breathe deep, feel present.",
      "Inhale hope, exhale worry."
    ];
    // Se selecciona una frase al azar del array
    const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
    this.descriptionBox.innerHTML = `<p>${randomPhrase}</p>`;
  }
  // Encuentra el item seleccionado en la lista:
  const selectedItem = this.presetListContainer.querySelector(`.dropdown-item[data-value="${preset.id}"]`);
  if (selectedItem) {
    // Si el contenedor ya está en el DOM, se remueve de su posición actual.
    if (this.descriptionBox.parentElement) {
      this.descriptionBox.parentElement.removeChild(this.descriptionBox);
    }
    // Inserta el contenedor justo debajo del item seleccionado.
    selectedItem.insertAdjacentElement('afterend', this.descriptionBox);
  }
}
    selectPreset(id, shouldHighlight = true) {
  const preset = this.presets.find(p => p.id === id);
  if (preset) {
    document.getElementById('circle1').value = preset.values[0];
    document.getElementById('circle2').value = preset.values[1];
    document.getElementById('circle3').value = preset.values[2];
    document.getElementById('circle4').value = preset.values[3];
    document.getElementById('circle5').value = preset.values[4];
    updateLargeCircle();
    emitInputChangeEvent();
    this.dropdownButton.textContent = preset.name;

    if (shouldHighlight) {
      const dropdownItems = this.presetListContainer.querySelectorAll('.dropdown-item');
      dropdownItems.forEach(item => {
        if (item.dataset.value === id) {
          item.classList.add('selected');
        } else {
          item.classList.remove('selected');
        }
      });

      // **Llamada a highlightPhasesSequential**
      this.highlightPhasesSequential(preset.values);
    }
// **Nueva línea:** actualiza y posiciona el recuadro explicativo debajo del item seleccionado
this.updateDescriptionBox(preset);

    localStorage.setItem('breathingSelectedPreset', id);
    saveSettingsToLocalStorage();
  }
}

/**
 * Resalta cada fase del círculo grande secuencialmente.
 * @param {Array} values - Array de valores [c1, c2, c3, c4, c5].
 */
highlightPhasesSequential(values) {
  // Si existen timeouts pendientes de una ejecución anterior, se cancelan.
  if (!this.highlightTimeouts) {
    this.highlightTimeouts = [];
  } else {
    this.highlightTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    this.highlightTimeouts = [];
  }
  
  const [c1, c2, c3, c4] = values;
  const segments = [
    { phase: 1, val: c1 },
    { phase: 2, val: c2 },
    { phase: 3, val: c3 },
    { phase: 4, val: c4 }
  ];
  
  let delay = 0;
  
  segments.forEach((seg) => {
    if (seg.val > 0) {
      const timeoutId = setTimeout(() => {
        highlightPhaseSegment(seg.phase, seg.val);
      }, delay);
      this.highlightTimeouts.push(timeoutId);
      delay += 1500;
    }
  });
  
  // Tras el total de fases, se muestra la aguja temporal (circle5) sin auto-ocultarse inicialmente
  const timeoutIdTemp = setTimeout(() => {
    const c5Value = parseInt(document.getElementById('circle5').value, 10) || 5;
    showTempNeedle(c5Value, 0);  // Se muestra indefinidamente
    
    // Luego, se oculta la aguja y sus textos después de 2 segundos
    const timeoutIdHide = setTimeout(() => {
      hideTempNeedleInstant();
      phaseHighlight.style.opacity = '0'; 
      phaseHighlightValue.style.opacity = '0'; 
    }, 2000);
    this.highlightTimeouts.push(timeoutIdHide);
  }, delay);
  this.highlightTimeouts.push(timeoutIdTemp);
}

savePreset() {
  if (this.presets.length >= 99) {
    alert('The maximum of 99 presets has been reached.');
    return;
  }

  let presetNameInput = prompt('Enter the preset name; the values will be added automatically:', 'New Preset');
  if (presetNameInput === null) return; // Si el usuario cancela, salir de la función

  presetNameInput = presetNameInput.trim();
  // Limitar la cadena ingresada por el usuario a 25 caracteres
  if (presetNameInput.length > 18) {
    presetNameInput = presetNameInput.substring(0, 18);
  }

  while (presetNameInput.length === 0 || this.isNameDuplicate(presetNameInput)) {
    if (presetNameInput.length === 0) {
      alert('The preset name cannot be empty.');
    } else {
      presetNameInput = prompt('The entered name already exists. Please enter a different one:', presetNameInput);
    }
    if (presetNameInput === null) return; // Si el usuario cancela, salir de la función
    presetNameInput = presetNameInput.trim();
    if (presetNameInput.length > 18) {
      presetNameInput = presetNameInput.substring(0, 18);
    }
  }

  alert("Data is saved in the browser. Clearing history will delete the presets.");

  const values = [
    parseInt(document.getElementById('circle1').value, 10) || 1,
    parseInt(document.getElementById('circle2').value, 10) || 0,
    parseInt(document.getElementById('circle3').value, 10) || 1,
    parseInt(document.getElementById('circle4').value, 10) || 0,
    parseInt(document.getElementById('circle5').value, 10) || 1
  ];

  const numbering = values.join('-');
  // El nombre final: [nombre del usuario (máx 20)] + separador, números y el emoji
  const newPreset = {
    id: generateUniqueId(),
    name: `${presetNameInput} - ${numbering} 🆕`,
    values,
    isFactory: false
  };

  this.presets.push(newPreset);
  const userPresets = this.presets.filter(p => !p.isFactory);
  localStorage.setItem('breathingUserPresets', JSON.stringify(userPresets));

  this.updateDropdownItems();
  this.selectPreset(newPreset.id, true);
}

  renamePreset() {
  const selectedPresetId = this.getSelectedPresetId();
  if (!selectedPresetId) {
    alert('No preset is selected for renaming.');
    return;
  }
  const preset = this.presets.find(p => p.id === selectedPresetId);
  if (!preset) {
    alert('Preset not found.');
    return;
  }
  if (preset.isFactory) {
    alert('Factory presets cannot be renamed.');
    return;
  }
  const currentBaseName = this.getPresetBaseName(preset);
  let newNameInput = prompt(`Rename the preset. "${preset.name}" to:`, currentBaseName);
  if (!newNameInput) return;
  newNameInput = newNameInput.trim();

  // Limitar el nuevo nombre a 25 caracteres
  if (newNameInput.length > 18) {
    newNameInput = newNameInput.substring(0, 18);
  }

  if (newNameInput.length === 0) {
    alert('The preset name cannot be empty.');
    return;
  }
  while (this.isNameDuplicate(newNameInput, preset.id)) {
    newNameInput = prompt('The entered name already exists. Please enter a different one:', '');
    if (!newNameInput) return;
    newNameInput = newNameInput.trim();
    if (newNameInput.length > 18) {
      newNameInput = newNameInput.substring(0, 18);
    }
    if (newNameInput.length === 0) {
      alert('The preset name cannot be empty.');
      return;
    }
  }
  const numbering = preset.values.join('-');
  // Se reconstruye el nombre con el emoji incluido
  preset.name = `${newNameInput} - ${numbering} 🆕`;
  const userPresets = this.presets.filter(p => !p.isFactory);
  localStorage.setItem('breathingUserPresets', JSON.stringify(userPresets));
  this.updateDropdownItems();
  this.dropdownButton.textContent = preset.name;

  const savedPresetId = localStorage.getItem('breathingSelectedPreset');
  if (savedPresetId === preset.id) {
    localStorage.setItem('breathingSelectedPreset', preset.id);
  }
}

    deletePreset() {
  const selectedPresetId = this.getSelectedPresetId();
  if (!selectedPresetId) {
    alert('No preset is selected for deletion.');
    return;
  }
  const preset = this.presets.find(p => p.id === selectedPresetId);
  if (!preset) {
    alert('Preset not found.');
    return;
  }
  if (preset.isFactory) {
    alert('Factory presets cannot be deleted.');
    return;
  }
  const confirmDelete = confirm(`Are you sure you want to delete the preset "${preset.name}"?`);
  if (!confirmDelete) return;
  this.presets = this.presets.filter(p => p.id !== selectedPresetId);
  


  const userPresets = this.presets.filter(p => !p.isFactory);
  localStorage.setItem('breathingUserPresets', JSON.stringify(userPresets));
  this.updateDropdownItems();

  if (this.presets.length > 0) {
    this.selectPreset(this.presets[0].id, true);
  } else {
    document.getElementById('circle1').value = 1;
    document.getElementById('circle2').value = 0;
    document.getElementById('circle3').value = 1;
    document.getElementById('circle4').value = 0;
    document.getElementById('circle5').value = 5;
    updateLargeCircle();
    emitInputChangeEvent();
    this.dropdownButton.textContent = 'Select Preset';
    localStorage.removeItem('breathingSelectedPreset');
  }
}

    getSelectedPresetId() {
      const selectedItem = this.presetListContainer.querySelector('.dropdown-item.selected');
      return selectedItem ? selectedItem.dataset.value : null;
    }

    getPresetBaseName(preset) {
      const separatorIndex = preset.name.lastIndexOf(' - ');
      if (separatorIndex === -1) return preset.name;
      return preset.name.substring(0, separatorIndex);
    }

    isNameDuplicate(name, excludeId = null) {
      const normalizedInputName = name.trim().toLowerCase();
      return this.presets.some(pr => {
        if (excludeId && pr.id === excludeId) return false;
        const baseName = this.getPresetBaseName(pr).toLowerCase();
        return baseName === normalizedInputName;
      });
    }

    //isCurrentPreset(currentValues) {
     // return this.presets.find(pr => {
       // return pr.values.every((val, index) => val === currentValues[index]);
     // });
   // }

    updateDropdownButton(currentValues) {
  // Leemos el preset guardado (sin modificarlo)
  const savedPresetId = localStorage.getItem('breathingSelectedPreset');
  if (savedPresetId && savedPresetId !== 'custom') {
    const matchedPreset = this.presets.find(p => p.id === savedPresetId);
    if (matchedPreset) {
      // Comparamos los valores del preset con los actuales
      const [p1, p2, p3, p4, p5] = matchedPreset.values;
      if (p1 === currentValues[0] &&
          p2 === currentValues[1] &&
          p3 === currentValues[2] &&
          p4 === currentValues[3] &&
          p5 === currentValues[4]) {
        // Si coinciden, mostramos el nombre del preset y marcamos su opción en la lista
        this.dropdownButton.textContent = matchedPreset.name;
        const dropdownItems = this.presetListContainer.querySelectorAll('.dropdown-item');
        dropdownItems.forEach(item => {
          if (item.dataset.value === matchedPreset.id) {
            item.classList.add('selected');
          } else {
            item.classList.remove('selected');
          }
        });
        return;
      }
    }
  }
  // Si no hay un preset guardado válido o los valores no coinciden, mostramos "Custom"
  const [c1, c2, c3, c4, c5] = currentValues;
  const customName = `Custom - ${c1}-${c2}-${c3}-${c4}-${c5}`;
  this.dropdownButton.textContent = customName;
  const dropdownItems = this.presetListContainer.querySelectorAll('.dropdown-item');
  dropdownItems.forEach(item => item.classList.remove('selected'));
}
  }
  customElements.define('preset-dropdown', PresetDropdown);

  
</script>

    <!-- ======== CUSTOM ELEMENT <gong-dropdown> ======== -->
  <script>
    class GongDropdown extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        const template = document.createElement('template');
        template.innerHTML = `
          <style>
          :host {
  display: block;
  width: 100%;
  margin: 0 auto;
  font-family: Arial, sans-serif;
  box-sizing: border-box;
}

.dropdown {
  position: relative;
  text-align: center;
  width: 100%;
}

.dropdown-button {
  width: 100%;
  padding: 10px;
  font-size: 16px;
  text-align: left;
  border: 1px solid #000 !important;
  border-radius: 8px 8px 8px 8px !important;
  cursor: pointer;
  background-color: #2e3742;
  color: #ffffff;
  display: flex;
  align-items: center;
  justify-content: space-between;
  
}
.dropdown-button:hover {
  /*background-color: #3e4a4c;*/
}
/*.dropdown-button::after {
  content: '▼';
  font-size: 12px;
  margin-left: 10px;
}*/


/* Estado cerrado: sin padding y sin overflow-y */
.dropdown-content {
  position: relative;
  max-height: 0;
  overflow: hidden;               /* Solo overflow hidden en estado cerrado */
  opacity: 0;
  transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
  border: 4px solid #000;
  border-radius: 4px 4px 8px 8px;
  box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
  padding: 0;                     /* Sin padding al estar cerrado */
  box-sizing: border-box;
  background: radial-gradient(circle, var(--menu-bg-1, #1a3a47), var(--menu-bg-2, #050c12));
  box-shadow: 0px 1px 3px rgba(255, 255, 255, 0.5);
  color: #ffffff;
}

/* Estado abierto: se restaura el padding y se activa el scroll vertical */
.dropdown-content.show {
  overflow-y: auto;               /* Activa el scroll vertical */
  max-height: 400px;              /* Altura final expandida (ajusta según tu contenido) */
  opacity: 1;
  padding: 10px;                  /* Padding deseado cuando esté abierto */
}
/*//////////////////////////////////////////*/
/* Evitar scroll horizontal en toda la página */
html, body {
  margin: 0;
  padding: 0;
  overflow-x: hidden;
}

/* Contenedor del título y fader */
.menu-title {
    background-color: rgba(000, 000, 000, 0.25);/* Color de fondo diferente */
    padding: 10px;
    margin: 0 -0px 15px -0px; /* Expande el fondo 3px hacia los lados */
    border-radius: 4px; /* Bordes redondeados opcionales */
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start; /* Alinea el contenido a la izquierda */
    height: 40px; /* Mantiene altura uniforme */
    width: calc(100% + 0px); /* Aumenta el ancho total en 6px (3px a cada lado) */
    padding-left: 10px; /* Espaciado interno para el texto */
}

/* Estilo para el texto del título */
.menu-title strong {
  color: #ffcc00;
  font-size: 16px;
  margin: 0;
  margin-right: 0px;              /* Espacio entre el título y el fader */
  flex: 0 0 auto;                 /* Toma solo el ancho necesario */
}

/* Estilo para el fader réplica en el menú */
.menu-title input[type="range"] {
  flex: 1;                        /* Ocupa el espacio restante disponible */
  -webkit-appearance: none;
  appearance: none;
  height: 1px;
  background: #b2dfdb;
  outline: none;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  /* Opcional: si deseas algo de espacio a los lados, podrías usar:
     margin: 0 10px;
  */
}

/* Personalización del thumb para navegadores WebKit */
.menu-title input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 17px;
  height: 17px;
  border-radius: 50%;
   background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  /* Ajusta este valor para centrar verticalmente el thumb:
     En este ejemplo, si la altura es 40px y el track está centrado, 
     un margin-top de alrededor de -8px suele funcionar */
  margin-top: -0px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  filter: hue-rotate(var(--my-hue));
}

/* Personalización del thumb para Firefox */
.menu-title input[type="range"]::-moz-range-thumb {
  width: 17px;
  height: 17px;
  border-radius: 50%;
   background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  filter: hue-rotate(var(--my-hue));
}
/*////////////////////////*/

strong {
  display: block;
  text-align: left; /* Alineación a la izquierda */
  margin: 10px 0 5px 0;
  color: #ffcc00; 
  padding-left: 5px; /* Opcional: espacio extra desde el borde izquierdo */
}

/* Títulos y separadores sin cambios */
.dropdown-separator {
  border-top: 1px solid #000;
  margin: 15px 0;
}
strong {
  margin: 10px 0 5px 0;
  color: #ffcc00; 
}

.loop-container {
  display: inline-flex;
  align-items: center;
  margin-bottom: 10px;
}
.loop-container label {
  margin-left: 5px;
  font-size: 14px;
  color: #ffcc00;
  cursor: pointer;
}
.loop-container input[type="checkbox"] {
  visibility: hidden; /* invisible */
  position: absolute; 
  pointer-events: none;
}
label[for="ambient2-loop-checkbox"] {
  opacity: 0; /* Texto invisible */
}

/* 
   Rejilla de 3 columnas para cada grupo de imágenes.
   Esto NO afecta a los títulos ni checkboxes porque
   están fuera de .gong-grid.
*/
.gong-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* 3 columnas */
  gap: 10px;                             /* separación */
  margin-bottom: 10px;                   /* espacio extra */
}

/* Cada item en la rejilla es un "bloque" con ratio 3:2 */
.dropdown-item {
  display: block;
  position: relative;
  cursor: pointer;
  transition: background-color 0.3s;
  /* para bordes redondeados consistentes */
  border-radius: 8px;  
  overflow: hidden; /* las esquinas del contenido se redondeen */
  
  /* Relación 3:2 para imágenes 300x200 */
  aspect-ratio: 3 / 2; 

  /*box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.7); /* Sombra blanca suave */*/

}

/* Imagen llena todo el .dropdown-item */
.dropdown-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;          /* recorta sobrante */
  border: 3px solid transparent; 
  border-radius: 8px;         /* mismo radio */
  box-sizing: border-box;
}

/* Hover: un leve oscurecido de fondo (opcional) */
.dropdown-item:hover {
 /* background-color: #304245;*/
}

  .dropdown-item.selected img {
    border-color: #00C6FF;; 
  }

    .dropdown-item.selected::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 120, 215, 0.3); /* Verde translúcido */
  pointer-events: none; /* Permite que los clics pasen a la imagen */
  border-radius: 8px;   /* Mantiene las esquinas redondeadas */
}

/* Cuando un ítem está en preview, overlay verde */
.dropdown-item.previewing::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 255, 0, 0.3); /* Verde translúcido */
  pointer-events: none;  /* Para que no bloquee clics */
  border-radius: 8px;    /* Ajusta al radio de tus .dropdown-item */
}

/* Si quieres que el borde del ítem sea verde en lugar del overlay:
.dropdown-item.previewing img {
  border-color: #0f0 !important; 
}
*/

/* //////////////////////*/

/* Botón de dropdown con alineación correcta */
.dropdown-button {
    display: flex;
    align-items: center;
    justify-content: space-between; /* Asegura que la flecha se mantenga a la derecha */
    width: 100%;  
    padding: 10px 15px;
    white-space: nowrap;
    overflow: hidden;
    background-color: #2e3742;
    color: #ffffff;
    border: none;
    border-radius: 8px;
    cursor: pointer;
}

/* Contenedor del texto dentro del botón */
.button-text-container {
    flex-grow: 1;  /* Permite que el texto use el espacio disponible */
    display: flex;
    justify-content: flex-start;
    align-items: center;
    overflow: hidden;
}

/* Flecha separada completamente del texto */
.dropdown-arrow {
color: #000000; /* Cambia este color según lo que necesites */
    flex-shrink: 0; /* Evita que la flecha cambie de tamaño */
    margin-left: 10px;  /* Espacio entre el texto y la flecha */
}

/* Texto resaltado */
.selected-text {
    color: #00C6FF;  /* Azul claro */
    font-weight: 600; /* O 200, 300, etc. */
}



         </style>
   <div class="dropdown">
          <button class="dropdown-button">Select Chime</button>
          <div class="dropdown-content">
            <!-- Sección Chime -->
            <div class="menu-chime">
              <div class="menu-title">
                <strong>Chime</strong>
                <input type="range" id="gong-fader-menu" min="0" max="100" value="50">
              </div>
              <div class="gong-grid">
                 <div class="dropdown-item" data-value="none">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Mute-with-background-300x200-1.jpg" alt="None" />
                </div>
                <!-- Ejemplo en la rejilla "menu-chime .gong-grid" -->
<div class="dropdown-item" data-value="gong_special">
  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/voice.jpeg" alt="Voice" />
</div>
                <div class="dropdown-item" data-value="gong1">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Open-Bell-300x200-1.jpeg" alt="Open Bell" />
                </div>
                <div class="dropdown-item" data-value="gong2">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Chokke-Bowl-300x200-1.jpeg" alt="Choke Bowl" />
                </div>
                <div class="dropdown-item" data-value="gong3">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Singing-Bowl.jpeg" alt="Singing Bowl" />
                </div>
                <div class="dropdown-item" data-value="gong4">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Shaking-Bells-300x300-1.avif" alt="Shaking Bell" />
                </div>
                <div class="dropdown-item" data-value="gong5">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Temple-Wood.jpeg" alt="Temple Wood" />
                </div>
                <div class="dropdown-item" data-value="gong6">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Gong-300x200-1.jpeg" alt="Temple Gong" />
                </div>
                <div class="dropdown-item" data-value="gong7">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Kick-gong-300x200-1.jpg" alt="Kick Gong" />
                </div>
                <!-- Celda de subida para Chime -->
                <div class="dropdown-item" data-value="gong_upload">
                  <label for="gong-upload-input">
                    <img class="custom-upload-icon" src="https://unmatrixlab.com/wp-content/uploads/2025/02/folder-music-icon.png" alt="Upload Custom Chime" />
                  </label>
                  <input type="file" id="gong-upload-input" accept="audio/*" style="display: none;">
                </div>
              </div>
            </div>
            <!-- Sección End Chime -->
            <div class="menu-chime-final">
              <div class="menu-title">
                <strong>End Chime</strong>
                <input type="range" id="gong-final-fader-menu" min="0" max="100" value="50">
              </div>
              <div class="gong-grid">
                <div class="dropdown-item" data-value="none_final">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Mute-with-background-300x200-1.jpg" alt="None" />
                </div>
                  <div class="dropdown-item" data-value="final_gong0">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/voice.jpeg" alt="End Voice" />
                </div>
                <div class="dropdown-item" data-value="final_gong1">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Gong-300x200-1.jpeg" alt="Temple Gong" />
                </div>
                <div class="dropdown-item" data-value="final_gong2">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Kick-gong-300x200-1.jpg" alt="Kick Gong" />
                </div>
                <div class="dropdown-item" data-value="final_gong3">
                  <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Shaking-Bells-300x300-1.avif" alt="Shaking Bell" />
                </div>
                <!-- Celda de subida para End Chime -->
                <div class="dropdown-item" data-value="final_gong_upload">
                  <label for="final-gong-upload-input">
                    <img class="custom-upload-icon" src="https://unmatrixlab.com/wp-content/uploads/2025/02/folder-music-icon.png" alt="Upload Custom Final Chime" />
                  </label>
                  <input type="file" id="final-gong-upload-input" accept="audio/*" style="display: none;">
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
      this.shadowRoot.appendChild(template.content.cloneNode(true));
    }

    connectedCallback() {
      // Referencias generales
      this.dropdownButton = this.shadowRoot.querySelector('.dropdown-button');
      this.dropdownContent = this.shadowRoot.querySelector('.dropdown-content');

      // --- Selección inicial ---
      if (currentGong === 'gong_custom') {
        this.selectGong('gong_upload');  // marca la celda de subida
      } else {
        this.selectGong(currentGong || 'gong1');
      }
      if (currentFinalGong === 'final_gong_custom') {
        this.selectFinalGong('final_gong_upload');
      } else {
        this.selectFinalGong(currentFinalGong || 'final_gong1');
      }

      // Mostrar/ocultar menú
     this.dropdownButton.addEventListener('click', (e) => {
  e.stopPropagation();
  if (this.dropdownContent.classList.contains('show')) {
    // Al colapsar el menú, detenemos el preview activo.
    stopCurrentPreview();
    this.dropdownContent.classList.remove('show');
    if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
      window.__CURRENT_OPEN_DROPDOWN__ = null;
    }
  } else {
    this.closeAllOthers();
    this.dropdownContent.classList.add('show');
    window.__CURRENT_OPEN_DROPDOWN__ = this;
  }
});
      this.dropdownContent.addEventListener('click', (e) => e.stopPropagation());
      document.addEventListener('click', (e) => {
        if (!this.shadowRoot.contains(e.target)) {
          this.closeDropdown();
        }
      });

      // Asignar click solo a cada grupo (usando sus contenedores)
      const chimeContainer = this.shadowRoot.querySelector('.menu-chime .gong-grid');
      const finalContainer = this.shadowRoot.querySelector('.menu-chime-final .gong-grid');

      if (chimeContainer) {
        const chimeItems = chimeContainer.querySelectorAll('.dropdown-item');
        chimeItems.forEach(item => {
          item.addEventListener('click', () => {
            const val = item.getAttribute('data-value');
            // Si es upload, el <label> ya abre el input file, no hacemos nada
            if (val !== 'gong_upload') {
              this.selectGong(val);
              saveSettingsToLocalStorage();
            }
              // 2) Preview si la app está en reposo  || isPaused
if (val === 'gong_special') {
  const previewBuff = specialPhaseChimeBuffers['inhalation'];
  if (previewBuff) {
    previewAudio('gong_special_inhalation', previewBuff, 0);
  } 
} else {
  const buff = gongBuffers[val];
  if (buff) {
    // Mandas val como itemId, y buff como AudioBuffer
    previewAudio(val, buff, 0);
  } else {stopCurrentPreview();}
}
          });
        });
      }
     if (finalContainer) {
  const finalItems = finalContainer.querySelectorAll('.dropdown-item');
  finalItems.forEach(item => {
    item.addEventListener('click', () => {
      const val = item.getAttribute('data-value');
      if (val !== 'final_gong_upload') {
        this.selectFinalGong(val);
        saveSettingsToLocalStorage();
      }
      if (areBuffersLoaded && (!isPlaying || isPaused)) {
        const buff = gongBuffers[val]; 
        if (buff) {
          // la clave es pasar val como PRIMER argumento:
          previewAudio(val, buff, 0);
        } else {stopCurrentPreview();}
      }
    });
  });
}

      // Manejo de input:file
      const gongUploadInput = this.shadowRoot.querySelector('#gong-upload-input');
      const finalGongUploadInput = this.shadowRoot.querySelector('#final-gong-upload-input');

      gongUploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          gongBuffers['gong_custom'] = audioBuffer;
          currentGong = 'gong_custom';
          this.selectGong('gong_upload');
          saveSettingsToLocalStorage();
          if (isPlaying && !isPaused) { playGong(); }
          console.log('Archivo personalizado para Chime cargado.');
        } catch (err) {
          console.error('Error subiendo archivo Chime:', err);
          alert('No se pudo decodificar el archivo de audio para Chime.');
        }

      });

      

      finalGongUploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          gongBuffers['final_gong_custom'] = audioBuffer;
          currentFinalGong = 'final_gong_custom';
          this.selectFinalGong('final_gong_upload');
          saveSettingsToLocalStorage();
          if (isPlaying && !isPaused) { playFinalGong(); }
          console.log('Archivo personalizado para End Chime cargado.');
        } catch (err) {
          console.error('Error subiendo archivo End Chime:', err);
          alert('No se pudo decodificar el archivo de audio para End Chime.');
        }
        
      });
    }

    

    closeDropdown() {
      stopCurrentPreview(); 
      this.dropdownContent.classList.remove('show');
      if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      } 
    }

    closeAllOthers() {
      stopCurrentPreview();
      if (window.__CURRENT_OPEN_DROPDOWN__ && window.__CURRENT_OPEN_DROPDOWN__ !== this) {
        if (window.__CURRENT_OPEN_DROPDOWN__.closeDropdown) {
          window.__CURRENT_OPEN_DROPDOWN__.closeDropdown();
        }
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      }
    }

    // --- Selección para Chime (se limita al contenedor de Chime) ---
    selectGong(value) {
      const chimeContainer = this.shadowRoot.querySelector('.menu-chime .gong-grid');
      if (chimeContainer) {
        const items = chimeContainer.querySelectorAll('.dropdown-item');
        items.forEach(item => {
          const val = item.getAttribute('data-value');
          if (val) {
            if (val === value) {
              item.classList.add('selected');
            } else {
              item.classList.remove('selected');
            }
          }
        });
      }
      currentGong = (value === 'gong_upload') ? 'gong_custom' : value;
      this.updateButtonText();
      //if (isPlaying && !isPaused) { playGong(); }
    }

    // --- Selección para End Chime (limitado al contenedor final) ---
    selectFinalGong(value) {
      const finalContainer = this.shadowRoot.querySelector('.menu-chime-final .gong-grid');
      if (finalContainer) {
        const items = finalContainer.querySelectorAll('.dropdown-item');
        items.forEach(item => {
          const val = item.getAttribute('data-value');
          if (val) {
            if (val === value) {
              item.classList.add('selected');
            } else {
              item.classList.remove('selected');
            }
          }
        });
      }
      currentFinalGong = (value === 'final_gong_upload') ? 'final_gong_custom' : value;
      this.updateButtonText();
      //if (isPlaying && !isPaused) { playFinalGong(); }
    }

    updateButtonText() {
      // Buscar la selección en el contenedor Chime
      let chimeText = 'None';
      const chimeContainer = this.shadowRoot.querySelector('.menu-chime .gong-grid');
      const chimeSelected = chimeContainer ? chimeContainer.querySelector('.dropdown-item.selected') : null;
      if (chimeSelected) {
        const val = chimeSelected.getAttribute('data-value');
        const img = chimeSelected.querySelector('img');
        chimeText = (val === 'gong_upload') ? 'Custom' : (img ? img.getAttribute('alt') : 'Unknown');
      }
      // Buscar la selección en el contenedor Final Chime
      let finalText = 'None';
      const finalContainer = this.shadowRoot.querySelector('.menu-chime-final .gong-grid');
      const finalSelected = finalContainer ? finalContainer.querySelector('.dropdown-item.selected') : null;
      if (finalSelected) {
        const val = finalSelected.getAttribute('data-value');
        const img = finalSelected.querySelector('img');
        finalText = (val === 'final_gong_upload') ? 'Custom' : (img ? img.getAttribute('alt') : 'Unknown');
      }
        // Modificar el botón con texto resaltado
    this.dropdownButton.innerHTML = `
    <div class="button-text-container">
        <span>Chime: <span class="selected-text truncate">${chimeText}</span></span> -
        <span>End: <span class="selected-text truncate">${finalText}</span></span>
    </div>
    <span class="dropdown-arrow">▼</span>
`;
    }
  }

  customElements.define('gong-dropdown', GongDropdown);
</script>

    <!-- ======== CUSTOM ELEMENT <ambient-dropdown> ======== -->
  <script>
    class AmbientDropdown extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        const template = document.createElement('template');
        template.innerHTML = `
   <style>
  :host {
    display: block;
    width: 100%;
    margin: 0 auto;
    font-family: Arial, sans-serif;
    box-sizing: border-box;
  }

  .dropdown {
    position: relative;
    text-align: center;
    width: 100%;
  }

  .dropdown-button {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    text-align: left;
    border: 1px solid #000 !important;
    border-radius: 8px;
    cursor: pointer;
    background-color: #2e3742;
    color: #ffffff;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .dropdown-button:hover {
   /* background-color: #3e4a4c;*/
  }

  /*.dropdown-button::after {
    content: '▼';
    font-size: 12px;
    margin-left: 10px;
  }*/

/* Estado cerrado: sin padding y sin overflow-y */
.dropdown-content {
  position: relative;
  max-height: 0;
  overflow: hidden;               /* Solo overflow hidden en estado cerrado */
  opacity: 0;
  transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
  border-radius: 4px 4px 8px 8px !important;
  border-radius: 4px;
  box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
  padding: 0;                     /* Sin padding al estar cerrado */
  box-sizing: border-box;
  background: radial-gradient(circle, var(--menu-bg-1, #1a3a47), var(--menu-bg-2, #050c12));
  box-shadow: 0px 1px 3px rgba(255, 255, 255, 0.5);
  color: #ffffff;
}

/* Estado abierto: se restaura el padding y se activa el scroll vertical */
.dropdown-content.show {
  overflow-y: auto;               /* Activa el scroll vertical */
  max-height: 400px;              /* Altura final expandida (ajusta según tu contenido) */
  opacity: 1;
  padding: 10px;                  /* Padding deseado cuando esté abierto */
}

  .title-container {
    background-color: rgba(000, 000, 000, 0.25);/* Color de fondo diferente */
    padding: 10px;
    margin: 0 20px 20px 0px; /* Márgenes: arriba, derecha, abajo, izquierda */
    border-radius: 4px; /* Bordes redondeados opcionales */
    box-sizing: border-box;
    width: auto; /* Asegura que el ancho se ajuste correctamente dentro del contenedor */
}



  .dropdown-separator {
    border-top: 1px solid #000;
    margin: 15px 0;
  }

  /* Contenedor de título y checkbox */
  .title-container {
    display: flex;
    align-items: center;
    justify-content: space-between; /* Empuja el checkbox a la derecha */
    width: 100%;
    padding-right: 10px; /* Espaciado para que el checkbox no toque el borde */
  }

  strong {
    text-align: left;
    color: #ffcc00;
    padding-left: 5px;
  }


  /* Estilo para el fader réplica en el menú */
.title-container input[type="range"] {
  flex: 1;                        /* Ocupa el espacio restante disponible */
  -webkit-appearance: none;
  appearance: none;
  height: 1px;
  background: #b2dfdb;
  outline: none;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  /* Opcional: si deseas algo de espacio a los lados, podrías usar:
     margin: 0 10px;
  */
}

  /* Personalización del thumb para navegadores WebKit */
.title-container input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 17px;
  height: 17px;
  border-radius: 50%;
    background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  /* Ajusta este valor para centrar verticalmente el thumb:
     En este ejemplo, si la altura es 40px y el track está centrado, 
     un margin-top de alrededor de -8px suele funcionar */
  margin-top: -0px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* Personalización del thumb para Firefox */
.title-container input[type="range"]::-moz-range-thumb {
  width: 17px;
  height: 17px;
  border-radius: 50%;
    background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

  

  .loop-container {
    display: inline-flex;
    align-items: center;
  }

  .loop-container label {
    font-size: 14px;
    color: #ffcc00;
    cursor: pointer;
  }

  .loop-container input[type="checkbox"] {
    width: 16px;
    height: 16px;
    margin-left: 5px;
  }

  /* Ajuste de la rejilla de imágenes */
  .gong-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 3 columnas */
    gap: 10px;
    margin-bottom: 10px;
  }

  .dropdown-item {
    display: block;
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s;
    border-radius: 8px;
    overflow: hidden;
    aspect-ratio: 3 / 2;
  }

  .dropdown-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border: 3px solid transparent;
    border-radius: 8px;
    box-sizing: border-box;
  }

  .dropdown-item:hover {
   /* background-color: #304245;*/
  }

  .dropdown-item.selected img {
    border-color: #00C6FF;; 
  }

    .dropdown-item.selected::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 120, 215, 0.3); /* Verde translúcido */
  pointer-events: none; /* Permite que los clics pasen a la imagen */
  border-radius: 8px;   /* Mantiene las esquinas redondeadas */
}

/* Cuando un ítem está en preview, overlay verde */
.dropdown-item.previewing::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 255, 0, 0.3); /* Verde translúcido */
  pointer-events: none;  /* Para que no bloquee clics */
  border-radius: 8px;    /* Ajusta al radio de tus .dropdown-item */
}

/* Si quieres que el borde del ítem sea verde en lugar del overlay:
.dropdown-item.previewing img {
  border-color: #0f0 !important; 
}
*/


/* Estilo base para ambos checkboxes */
#ambient1-loop-checkbox, 
#ambient2-loop-checkbox {
    appearance: none;
    width: 20px;
    height: 20px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: #404245; 
    cursor: pointer;
    position: relative;
    transition: border-color 0.3s ease;
}

/* Se crea una pseudo-capa con el gradiente */
#ambient1-loop-checkbox::before,
#ambient2-loop-checkbox::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(60deg, #e4f00a, #fff);
    border-radius: 4px;
    opacity: 0; /* Oculto por defecto */
    transition: opacity 0.3s ease;
}

/* Cuando están marcados, se muestra el gradiente */
#ambient1-loop-checkbox:checked::before,
#ambient2-loop-checkbox:checked::before {
    opacity: 1; /* Se activa el gradiente sin parpadeo */
}

/* Borde cambia cuando están activados */
#ambient1-loop-checkbox:checked,
#ambient2-loop-checkbox:checked {
    border-color: #ccc;
}
/*---------------*/

/* Botón de dropdown con alineación correcta */
.dropdown-button {
    display: flex;
    align-items: center;
    justify-content: space-between; /* Asegura que la flecha se mantenga a la derecha */
    width: 100%;  
    padding: 10px 15px;
    white-space: nowrap;
    overflow: hidden;
    background-color: #2e3742;
    color: #ffffff;
    border: none;
    border-radius: 8px;
    cursor: pointer;
}

/* Contenedor del texto dentro del botón */
.button-text-container {
    flex-grow: 1;  /* Permite que el texto use el espacio disponible */
    display: flex;
    justify-content: flex-start;
    align-items: center;
    overflow: hidden;
}

/* Flecha separada completamente del texto */
.dropdown-arrow {
color: #000000; 
    flex-shrink: 0; /* Evita que la flecha cambie de tamaño */
    margin-left: 10px;  /* Espacio entre el texto y la flecha */
}

.loop-active .dropdown-arrow  {
 color: yellow;
    flex-shrink: 0; /* Evita que la flecha cambie de tamaño */
    margin-left: 10px;  /* Espacio entre el texto y la flecha */
}

/* Texto resaltado */
.selected-text {
    color: #00C6FF;  /* Azul claro */
    font-weight: 600; /* O 200, 300, etc. */
}



</style>

     <div class="dropdown">
          <button class="dropdown-button">Select Environment</button>
          <div class="dropdown-content">
            
            <!-- Environment A -->
            <div class="title-container">
              <strong>Environment A</strong>
              <input type="range" id="ambient1-fader-menu" min="0" max="100" value="50">
              <div class="loop-container">
                <label for="ambient1-loop-checkbox">Hold</label>
                <input type="checkbox" id="ambient1-loop-checkbox" checked>
              </div>
            </div>
            <div class="gong-grid">
            <div class="dropdown-item" data-value="ambient1_none">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Mute-with-background-300x200-1.jpg" alt="None" />
</div>
<div class="dropdown-item" data-value="ambient1_1">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/campfire-300x200-1.jpg" alt="Fire" />
</div>
<div class="dropdown-item" data-value="ambient1_2">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Storm-300x200-1.jpg" alt="Thunder-Rain" />
</div>
<div class="dropdown-item" data-value="ambient1_3">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/RiverBirds-300x200-1.jpg" alt="River & Birds" />
</div>
<div class="dropdown-item" data-value="ambient1_4">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/bird-singing-300x200-1.jpg" alt="Birds" />
</div>
<div class="dropdown-item" data-value="ambient1_5">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/wind-300x200-1.jpg" alt="Wind" />
</div>
<div class="dropdown-item" data-value="ambient1_6">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Train.jpeg" alt="Rain Train" />
</div>
<div class="dropdown-item" data-value="ambient1_7">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane.jpg" alt="Airplane" />
</div>
<div class="dropdown-item" data-value="ambient1_8">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane-2.jpg" alt="Airplane 2" />
</div>
<div class="dropdown-item" data-value="ambient1_9">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Snowstorm.jpg" alt="Snowstorm" />
</div>
<div class="dropdown-item" data-value="ambient1_10">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/rain-300x200-1.jpg" alt="Rain" />
</div>
<div class="dropdown-item" data-value="ambient1_11">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/ocean-wave-300x200-1.jpeg" alt="Ocean" />
</div>
<div class="dropdown-item" data-value="ambient1_12">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Storm-Soft.jpg" alt="Loud Storm" />
</div>
<div class="dropdown-item" data-value="ambient1_13">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Bamboo-Rain.jpg" alt="Bamboo Rain" />
</div>
<div class="dropdown-item" data-value="ambient1_14">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Fountain.jpg" alt="Fountain" />
</div>








              <!-- Celda “upload” A -->
           <div class="dropdown-item" data-value="ambient1_upload">
  <label for="ambient1-upload-input">
    <img class="custom-upload-icon" src="https://unmatrixlab.com/wp-content/uploads/2025/02/folder-music-icon.png"
         alt="Upload Custom A" />
  </label>
  <input type="file"
         id="ambient1-upload-input"
         accept="audio/*"
         style="display: none;" />
</div>
            </div>

            <div style="height: 10px;"></div>

            <!-- Environment B -->
            <div class="title-container">
              <strong>Environment B</strong>
              <input type="range" id="ambient2-fader-menu" min="0" max="100" value="50">
              <div class="loop-container">
                <label for="ambient2-loop-checkbox">Hold</label>
                <input type="checkbox" id="ambient2-loop-checkbox" checked>
              </div>
            </div>
            <div class="gong-grid">
            <div class="dropdown-item" data-value="ambient2_none">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Mute-with-background-300x200-1.jpg" alt="None" />
</div>
<div class="dropdown-item" data-value="ambient2_1">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/campfire-300x200-1.jpg" alt="Fire" />
</div>
<div class="dropdown-item" data-value="ambient2_2">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Storm-300x200-1.jpg" alt="Thunder-Rain" />
</div>
<div class="dropdown-item" data-value="ambient2_3">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/RiverBirds-300x200-1.jpg" alt="River & Birds" />
</div>
<div class="dropdown-item" data-value="ambient2_4">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/bird-singing-300x200-1.jpg" alt="Birds" />
</div>
<div class="dropdown-item" data-value="ambient2_5">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/wind-300x200-1.jpg" alt="Wind" />
</div>
<div class="dropdown-item" data-value="ambient2_6">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Train.jpeg" alt="Rain Train" />
</div>
<div class="dropdown-item" data-value="ambient2_7">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane.jpg" alt="Airplane" />
</div>
<div class="dropdown-item" data-value="ambient2_8">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Airplane-2.jpg" alt="Airplane 2" />
</div>
<div class="dropdown-item" data-value="ambient2_9">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Snowstorm.jpg" alt="Snowstorm" />
</div>
<div class="dropdown-item" data-value="ambient2_10">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/rain-300x200-1.jpg" alt="Rain" />
</div>
<div class="dropdown-item" data-value="ambient2_11">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/ocean-wave-300x200-1.jpeg" alt="Ocean" />
</div>
<div class="dropdown-item" data-value="ambient2_12">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Storm-Soft.jpg" alt="Loud Storm" />
</div>
<div class="dropdown-item" data-value="ambient2_13">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Bamboo-Rain.jpg" alt="Bamboo Rain" />
</div>
<div class="dropdown-item" data-value="ambient2_14">
    <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Fountain.jpg" alt="Fountain" />
</div>




              <!-- Celda “upload” B -->
              <div class="dropdown-item" data-value="ambient2_upload">
                <label for="ambient2-upload-input">
                  <img class="custom-upload-icon" src="https://unmatrixlab.com/wp-content/uploads/2025/02/folder-music-icon.png"
                       alt="Upload Custom B" />
                </label>
                <input type="file"
                       id="ambient2-upload-input"
                       accept="audio/*"
                       style="display: none;" />
              </div>
            </div>
          </div>
        </div>
      `;
      this.shadowRoot.appendChild(template.content.cloneNode(true));
    }

    connectedCallback() {
      // Referencias
      this.dropdownButton = this.shadowRoot.querySelector('.dropdown-button');
      this.dropdownContent = this.shadowRoot.querySelector('.dropdown-content');
      this.dropdownItems = this.shadowRoot.querySelectorAll('.dropdown-item');

      // Checkboxes
      this.ambient1LoopCheckbox = this.shadowRoot.querySelector('#ambient1-loop-checkbox');
      this.ambient2LoopCheckbox = this.shadowRoot.querySelector('#ambient2-loop-checkbox');
      this.ambient1LoopCheckbox.checked = window.__ambient1LoopEnabled;
      this.ambient2LoopCheckbox.checked = window.__ambient2LoopEnabled;
      this.ambient1LoopCheckbox.addEventListener('change', () => {
        window.__ambient1LoopEnabled = this.ambient1LoopCheckbox.checked;
        saveSettingsToLocalStorage();
      });
      this.ambient2LoopCheckbox.addEventListener('change', () => {
        window.__ambient2LoopEnabled = this.ambient2LoopCheckbox.checked;
        saveSettingsToLocalStorage();
      });

      // Selección inicial: si la variable global es 'ambient1_custom' => UI = 'ambient1_upload'
      if (currentAmbient1 === 'ambient1_custom') {
        this.selectAmbient1('ambient1_upload');
      } else {
        this.selectAmbient1(currentAmbient1 || 'ambient1_none');
      }
      if (currentAmbient2 === 'ambient2_custom') {
        this.selectAmbient2('ambient2_upload');
      } else {
        this.selectAmbient2(currentAmbient2 || 'ambient2_none');
      }

      // Mostrar/ocultar menú
    this.dropdownButton.addEventListener('click', (e) => {
  e.stopPropagation();
  if (this.dropdownContent.classList.contains('show')) {
    // Al colapsar el menú, detenemos el preview activo.
    stopCurrentPreview();
    this.dropdownContent.classList.remove('show');
    if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
      window.__CURRENT_OPEN_DROPDOWN__ = null;
    }
  } else {
    this.closeAllOthers();
    this.dropdownContent.classList.add('show');
    window.__CURRENT_OPEN_DROPDOWN__ = this;
  }
});
      this.dropdownContent.addEventListener('click', (e) => e.stopPropagation());
      document.addEventListener('click', (e) => {
        if (!this.shadowRoot.contains(e.target)) {
          this.closeDropdown();
        }
      });

      // Click en items
      this.dropdownItems.forEach(item => {
        item.addEventListener('click', () => {
          const selectedValue = item.getAttribute('data-value');

          // Environment A
          if (selectedValue && selectedValue.startsWith('ambient1_')) {
            if (selectedValue !== 'ambient1_upload') {
              this.selectAmbient1(selectedValue);
              saveSettingsToLocalStorage();

        // 2) Preview si la app está en reposo o en pausa
        if (areBuffersLoaded && (!isPlaying || isPaused)) {
          let bufferKey = selectedValue;
          // “upload” => “custom” (solo si aplicara)
          // Pero como ya checamos !== 'ambient1_upload', no es tan crítico
          if (selectedValue === 'ambient1_upload') {
            bufferKey = 'ambient1_custom';
          }
          
          // Tomamos el buffer de “ambient1Buffers”
          const buff = ambient1Buffers[bufferKey];
          if (buff) {
            previewAudio(selectedValue,buff, 0, true); // 7 seg de preview
          }else {stopCurrentPreview();}
          } 
            }
          }
          // Environment B
          else if (selectedValue && selectedValue.startsWith('ambient2_')) {
            if (selectedValue !== 'ambient2_upload') {
              this.selectAmbient2(selectedValue);
              saveSettingsToLocalStorage();
              // 2) Preview si la app está en reposo o en pausa
        if (areBuffersLoaded && (!isPlaying || isPaused)) {
          let bufferKey = selectedValue;
          if (selectedValue === 'ambient2_upload') {
            bufferKey = 'ambient2_custom';
          }
          
          // Tomamos el buffer de “ambient2Buffers”
          const buff = ambient2Buffers[bufferKey];
          if (buff) {
            previewAudio(selectedValue,buff,0, true);
          }else {stopCurrentPreview();}
        }
            }
          }
        });
      });

      // Inputs file
      const ambient1UploadInput = this.shadowRoot.querySelector('#ambient1-upload-input');
      const ambient2UploadInput = this.shadowRoot.querySelector('#ambient2-upload-input');


      ambient1UploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          ambient1Buffers['ambient1_custom'] = audioBuffer;
          currentAmbient1 = 'ambient1_custom';

          // UI => 'upload'
          this.selectAmbient1('ambient1_upload');
          saveSettingsToLocalStorage();

          if (isPlaying && !isPaused) {
            playAmbient1();
          }
        } catch (err) {
          console.error('Error subiendo archivo A:', err);
          alert('No se pudo decodificar el audio A.');
        }
      });
      ambient2UploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          ambient2Buffers['ambient2_custom'] = audioBuffer;
          currentAmbient2 = 'ambient2_custom';

          this.selectAmbient2('ambient2_upload');
          saveSettingsToLocalStorage();

          if (isPlaying && !isPaused) {
            playAmbient2();
          }
        } catch (err) {
          console.error('Error subiendo archivo B:', err);
          alert('No se pudo decodificar el audio B.');
        }
      });
    }

    closeDropdown() {
      stopCurrentPreview();
      this.dropdownContent.classList.remove('show');
      if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      }
    }
    closeAllOthers() {
      stopCurrentPreview();
      if (window.__CURRENT_OPEN_DROPDOWN__ && window.__CURRENT_OPEN_DROPDOWN__ !== this) {
        if (window.__CURRENT_OPEN_DROPDOWN__.closeDropdown) {
          window.__CURRENT_OPEN_DROPDOWN__.closeDropdown();
        }
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      }
    }

    selectAmbient1(value) {
      // 1) Marcar la celda en la grid
      this.dropdownItems.forEach(item => {
        const val = item.getAttribute('data-value');
        if (val && val.startsWith('ambient1_')) {
          if (val === value) item.classList.add('selected');
          else item.classList.remove('selected');
        }
      });

      // 2) Actualizar variable global
      if (value === 'ambient1_upload') {
        currentAmbient1 = 'ambient1_custom';
      } else {
        currentAmbient1 = value;
      }

      // 3) Actualizar el texto del botón
      this.updateButtonText();

      // 4) Reproducir si en play
      if (isPlaying && !isPaused) {
        playAmbient1();
      }
    }
    selectAmbient2(value) {
      this.dropdownItems.forEach(item => {
        const val = item.getAttribute('data-value');
        if (val && val.startsWith('ambient2_')) {
          if (val === value) item.classList.add('selected');
          else item.classList.remove('selected');
        }
      });
      if (value === 'ambient2_upload') {
        currentAmbient2 = 'ambient2_custom';
      } else {
        currentAmbient2 = value;
      }
      this.updateButtonText();
      if (isPlaying && !isPaused) {
        playAmbient2();
      }
    }

    updateButtonText() {
      // A
      let textA = 'None';
      const aSelected = this.shadowRoot.querySelector('.dropdown-item.selected[data-value^="ambient1_"]');
      if (aSelected) {
        const val = aSelected.getAttribute('data-value');
        const img = aSelected.querySelector('img');
        if (val === 'ambient1_upload') {
          textA = 'Custom';
        } else {
          textA = img ? img.getAttribute('alt') : 'Unknown';
        }
      }
      // B
      let textB = 'None';
      const bSelected = this.shadowRoot.querySelector('.dropdown-item.selected[data-value^="ambient2_"]');
      if (bSelected) {
        const val = bSelected.getAttribute('data-value');
        const img = bSelected.querySelector('img');
        if (val === 'ambient2_upload') {
          textB = 'Custom';
        } else {
          textB = img ? img.getAttribute('alt') : 'Unknown';
        }
      }
      this.dropdownButton.innerHTML = `
    <div class="button-text-container">
        <span>Environment A: <span class="selected-text truncate">${textA}</span></span> -
        <span>B: <span class="selected-text truncate">${textB}</span></span>
    </div>
    <span class="dropdown-arrow">▼</span>
`;
    }
  }

  customElements.define('ambient-dropdown', AmbientDropdown);
</script>

  <!-- ======== CUSTOM ELEMENT <music-voice-training-dropdown> ======== -->
  <script>
    class MusicVoiceTrainingDropdown extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        const template = document.createElement('template');
        template.innerHTML = `
         <style>
  :host {
    display: block;
    width: 100%;
    margin: 0 auto;
    font-family: Arial, sans-serif;
    box-sizing: border-box;
  }

  .dropdown {
    position: relative;
    text-align: center;
    width: 100%;
  }

  .dropdown-button {
    width: 100%;
    padding: 10px;
    font-size: 16px;
    text-align: left;
    border: 1px solid #000 !important;
    /*border-radius: 4px 4px 20px 20px !important;*/
    border-radius: 8px;
    cursor: pointer;
    background-color: #2e3742;
    color: #ffffff;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .dropdown-button:hover {
   /* background-color: #3e4a4c;*/
  }


/* Estado cerrado: sin padding y sin overflow-y */
.dropdown-content {
  position: relative;
  max-height: 0;
  overflow: hidden;               /* Solo overflow hidden en estado cerrado */
  opacity: 0;
  transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
  border: 4px solid #000;
  /*border-radius: 4px 4px 8px 8px !important;*/
  border-radius:8px;
  box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
  padding: 0;                     /* Sin padding al estar cerrado */
  box-sizing: border-box;
  background: radial-gradient(circle, var(--menu-bg-1, #1a3a47), var(--menu-bg-2, #050c12));
  box-shadow: 0px 1px 3px rgba(255, 255, 255, 0.5);
  color: #ffffff; 
}

/* Estado abierto: se restaura el padding y se activa el scroll vertical */
.dropdown-content.show {
  overflow-y: auto;               /* Activa el scroll vertical */
  max-height: 400px;              /* Altura final expandida (ajusta según tu contenido) */
  opacity: 1;
  padding: 10px;                  /* Padding deseado cuando esté abierto */
}

.title-container {
    background-color: rgba(000, 000, 000, 0.25);/* Color de fondo diferente */
    padding: 10px;
    margin: 0 20px 20px 0px; /* Márgenes: arriba, derecha, abajo, izquierda */
    border-radius: 4px; /* Bordes redondeados opcionales */
    box-sizing: border-box;
    width: auto; /* Asegura que el ancho se ajuste correctamente dentro del contenedor */
}



  .dropdown-separator {
    border-top: 1px solid #000;
    margin: 15px 0;
  }

  /* Contenedor de título y checkbox */
  .title-container {
    display: flex;
    align-items: center;
    justify-content: space-between; /* Checkbox alineado a la derecha */
    width: 100%;
    padding-right: 10px;
  }

  strong {
    text-align: left;
    color: #ffcc00;
    padding-left: 5px;
  }

   /* Estilo para el fader réplica en el menú */
.title-container input[type="range"] {
  flex: 1;                        /* Ocupa el espacio restante disponible */
  -webkit-appearance: none;
  appearance: none;
  height: 1px;
  background: #b2dfdb;
  outline: none;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  /* Opcional: si deseas algo de espacio a los lados, podrías usar:
     margin: 0 10px;
  */
}

  /* Personalización del thumb para navegadores WebKit */
.title-container input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 17px;
  height: 17px;
  border-radius: 50%;
   background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  /* Ajusta este valor para centrar verticalmente el thumb:
     En este ejemplo, si la altura es 40px y el track está centrado, 
     un margin-top de alrededor de -8px suele funcionar */
  margin-top: -0px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* Personalización del thumb para Firefox */
.title-container input[type="range"]::-moz-range-thumb {
  width: 17px;
  height: 17px;
  border-radius: 50%;
    background-color: var(--knob-color);
      border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

  .loop-container {
    display: inline-flex;
    align-items: center;
  }

  .loop-container label {
    font-size: 14px;
    color: #ffcc00;
    cursor: pointer;
  }

  .loop-container input[type="checkbox"] {
    width: 16px;
    height: 16px;
    margin-left: 5px;
  }

  /* Estilo de la cuadrícula para imágenes */
  .gong-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 10px;
  }

  .dropdown-item {
    display: block;
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s;
    border-radius: 8px;
    overflow: hidden;
    aspect-ratio: 3 / 2;
    /*box-shadow: 3px 3px 5px #000000;*/
  }

  .dropdown-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border: 3px solid transparent;
    border-radius: 8px;
    box-sizing: border-box; 
  }

  .dropdown-item:hover {
    /*background-color: #304245;*/
  }

  .dropdown-item.selected img {
    border-color: #00C6FF;; 
  }
 

    .dropdown-item.selected::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 120, 215, 0.3); /* Verde translúcido */
  pointer-events: none; /* Permite que los clics pasen a la imagen */
  border-radius: 8px;   /* Mantiene las esquinas redondeadas */
}

/* Cuando un ítem está en preview, overlay verde */
.dropdown-item.previewing::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 255, 0, 0.3); /* Verde translúcido */
  pointer-events: none;  /* Para que no bloquee clics */
  border-radius: 8px;    /* Ajusta al radio de tus .dropdown-item */
}

/* Si quieres que el borde del ítem sea verde en lugar del overlay:
.dropdown-item.previewing img {
  border-color: #0f0 !important; 
}
*/

/* Estilo base para ambos checkboxes */
#music-loop-checkbox, 
#voice-training-loop-checkbox {
    appearance: none;
    width: 20px;
    height: 20px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: #404245;; /* Siempre blanco por defecto */
    cursor: pointer;
    position: relative;
    transition: border-color 0.3s ease;
}

/* Se crea una pseudo-capa con el gradiente */
#music-loop-checkbox::before,
#voice-training-loop-checkbox::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(60deg, #e4f00a, #fff);
    border-radius: 4px;
    opacity: 0; /* Oculto por defecto */
    transition: opacity 0.3s ease;
}

/* Cuando están marcados, se muestra el gradiente */
#music-loop-checkbox:checked::before,
#voice-training-loop-checkbox:checked::before {
    opacity: 1; /* Se activa el gradiente sin parpadeo */
}

/* Borde cambia cuando están activados */
#music-loop-checkbox:checked,
#voice-training-loop-checkbox:checked {
    border-color: #ccc;
}

/*-----------------*/

/* Botón de dropdown con alineación correcta */
.dropdown-button {
    display: flex;
    align-items: center;
    justify-content: space-between; /* Asegura que la flecha se mantenga a la derecha */
    width: 100%;  
    padding: 10px 15px;
    white-space: nowrap;
    overflow: hidden;
    background-color: /*#2e3742;*/
    color: #ffffff;
    border: none;
    border-radius: 8px;
    cursor: pointer;
}

/* Contenedor del texto dentro del botón */
.button-text-container {
    flex-grow: 1;  /* Permite que el texto use el espacio disponible */
    display: flex;
    justify-content: flex-start;
    align-items: center;
    overflow: hidden;
}

/* Flecha separada completamente del texto */
.dropdown-arrow {
color: #000000; 
    flex-shrink: 0; /* Evita que la flecha cambie de tamaño */
    margin-left: 10px;  /* Espacio entre el texto y la flecha */
}

/* Texto resaltado */
.selected-text {
    color: #00C6FF;  /* Azul claro */
    font-weight: 600; /* O 200, 300, etc. */
}


</style>

 <div class="dropdown">
          <button class="dropdown-button">Select Music & Voice Training</button>
          <div class="dropdown-content">

            <!-- Sección Music -->
            <div class="title-container">
              <strong>Music</strong>
              <input type="range" id="music-fader-menu" min="0" max="100" value="50">
              <div class="loop-container">
                <label for="music-loop-checkbox">Hold</label>
                <input type="checkbox" id="music-loop-checkbox" checked>
              </div>
            </div>
            <div class="gong-grid">
              <div class="dropdown-item" data-value="music_none">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Mute-with-background-300x200-1.jpg" alt="None" />
              </div>
              <div class="dropdown-item" data-value="music_1">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/03/Handpan.jpg" alt="Handpan" />
              </div>
              <div class="dropdown-item" data-value="music_2">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/01/Music-1.jpeg" alt="Heros" />
              </div>
              <div class="dropdown-item" data-value="music_3">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/03/Indian-Singer.jpeg" alt="Singer" />
              </div>
                   <div class="dropdown-item" data-value="music_4">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/03/old-film.jpg" alt="old-film" />
              </div>
              <!-- Subir archivo Music -->
              <div class="dropdown-item" data-value="music_upload">
                <label for="music-upload-input">
                  <img class="custom-upload-icon" src="https://unmatrixlab.com/wp-content/uploads/2025/02/folder-music-icon.png"
                       alt="Upload Custom Music" />
                </label>
                <input type="file"
                       id="music-upload-input"
                       accept="audio/*"
                       style="display: none;" />
              </div>
            </div>

            <!-- Sección Voice Training -->
            <div class="title-container">
              <strong>Relaxation Guide </strong>
              <input type="range" id="voice-training-fader-menu" min="0" max="100" value="50">
             <div class="loop-container">
                <!--  <label for="voice-training-loop-checkbox">Hold</label > -->
<input type="checkbox" id="voice-training-loop-checkbox" style="display: none;">
              </div>
            </div>
            <div class="gong-grid">
              <div class="dropdown-item" data-value="voice_training_none">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Mute-with-background-300x200-1.jpg" alt="None" />
              </div>
              <div class="dropdown-item" data-value="voice_training_1">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Voice-Training-1-300x200-1.jpeg" alt="5 min Morning Med" />
              </div>
              <div class="dropdown-item" data-value="voice_training_2">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/7oga-Guide-300x200-1.jpg" alt="10 min Relaxing" />
              </div>
              <div class="dropdown-item" data-value="voice_training_3">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Voice-Training-2.jpeg" alt="10 min Stop Thinking" />
              </div>
              <div class="dropdown-item" data-value="voice_training_4">
                <img src="https://unmatrixlab.com/wp-content/uploads/2025/02/Meditation-Ocean.jpeg" alt="5 Med" />
              </div>
              <!-- Subir archivo Voice -->
              <div class="dropdown-item" data-value="voice_training_upload">
                <label for="voice-training-upload-input">
                  <img class="custom-upload-icon" src="https://unmatrixlab.com/wp-content/uploads/2025/02/folder-music-icon.png"
                       alt="Upload Custom Voice" />
                </label>
                <input type="file"
                       id="voice-training-upload-input"
                       accept="audio/*"
                       style="display: none;" />
              </div>
            </div>

          </div>
        </div>
      `;

      this.shadowRoot.appendChild(template.content.cloneNode(true));
    }

    connectedCallback() {
      // Referencias
      this.dropdownButton = this.shadowRoot.querySelector('.dropdown-button');
      this.dropdownContent = this.shadowRoot.querySelector('.dropdown-content');
      this.dropdownItems = this.shadowRoot.querySelectorAll('.dropdown-item');

      // Checkboxes
      this.musicLoopCheckbox = this.shadowRoot.querySelector('#music-loop-checkbox');
      this.voiceTrainingLoopCheckbox = this.shadowRoot.querySelector('#voice-training-loop-checkbox');
      this.musicLoopCheckbox.checked = window.__musicLoopEnabled;
      this.voiceTrainingLoopCheckbox.checked = window.__voiceTrainingLoopEnabled;
      this.musicLoopCheckbox.addEventListener('change', () => {
        window.__musicLoopEnabled = this.musicLoopCheckbox.checked;
        saveSettingsToLocalStorage();
      });
      this.voiceTrainingLoopCheckbox.addEventListener('change', () => {
        window.__voiceTrainingLoopEnabled = this.voiceTrainingLoopCheckbox.checked;
        if (voiceTrainingSource) {
          voiceTrainingSource.loop = window.__voiceTrainingLoopEnabled;
        }
        saveSettingsToLocalStorage();
      });

      // Selección inicial
      if (currentMusic === 'music_custom') {
        this.selectMusic('music_upload');
      } else {
        this.selectMusic(currentMusic || 'music_none');
      }
      if (currentVoiceTraining === 'voice_training_custom') {
        this.selectVoiceTraining('voice_training_upload');
      } else {
        this.selectVoiceTraining(currentVoiceTraining || 'voice_training_none');
      }

      // Mostrar/ocultar
    this.dropdownButton.addEventListener('click', (e) => {
  e.stopPropagation();
  if (this.dropdownContent.classList.contains('show')) {
    // Al colapsar el menú, detenemos el preview activo.
    stopCurrentPreview();
    this.dropdownContent.classList.remove('show');
    if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
      window.__CURRENT_OPEN_DROPDOWN__ = null;
    }
  } else {
    this.closeAllOthers();
    this.dropdownContent.classList.add('show');
    window.__CURRENT_OPEN_DROPDOWN__ = this;
  }
});
      this.dropdownContent.addEventListener('click', (e) => e.stopPropagation());
      document.addEventListener('click', (e) => {
        if (!this.shadowRoot.contains(e.target)) {
          this.closeDropdown();
        }
      });

      // Click en cada item
      this.dropdownItems.forEach(item => {
        item.addEventListener('click', () => {
          const val = item.getAttribute('data-value');
          if (val && val.startsWith('music_') && !val.includes('upload')) {
            this.selectMusic(val);
            saveSettingsToLocalStorage();
             // b) Hacer preview si no se está reproduciendo, o si está en pausa
        if (areBuffersLoaded && (!isPlaying || isPaused)) {
          let bufferKey = val; 
          // en caso de que quisiéramos "music_upload" => "music_custom"
          // (aquí no aplica, porque ya lo excluimos en !val.includes('upload'))
          // pero te muestro cómo sería:
          if (val === 'music_upload') {
            bufferKey = 'music_custom';
          }

          const buff = musicVoiceTrainingBuffers[bufferKey];
          if (buff) {
            previewAudio(val, buff, 0, true);// 7 segundos
          } else {stopCurrentPreview();}
        }
     
            
          } else if (val && val.startsWith('voice_training_') && !val.includes('upload')) {
            this.selectVoiceTraining(val);
            saveSettingsToLocalStorage();
                    if (val === 'voice_training_none') {
          stopCurrentPreview();
        }
            //nuevo
               if (val !== 'voice_training_none' && musicVoiceTrainingBuffers[currentVoiceTraining]) {
        // 1) Calcula la duración del track en minutos
        const trackDurationSec = musicVoiceTrainingBuffers[currentVoiceTraining].duration;
        const trackDurationMin = Math.ceil(trackDurationSec / 60);

        // 2) Si circle5 es distinto, lo forzamos para que quepa el track completo
        const currentC5 = parseInt(document.getElementById('circle5').value, 10) || 0;
        if (currentC5 !== trackDurationMin) {
          document.getElementById('circle5').value = trackDurationMin;
          updateLargeCircle();
          saveSettingsToLocalStorage();
        }

        // 3) Forzamos mute al Chime/gong si no está muteado
        const gongMuteButton = document.querySelector('.mute-button[data-channel="gong"]');
        if (gongMuteButton && !isGongMuted) {
          toggleMute('gong', gongMuteButton);
        }

          // b) Preview si la app está en reposo o en pausa
        if (areBuffersLoaded && (!isPlaying || isPaused)) {
          let bufferKey = val;
          if (val === 'voice_training_upload') {
            bufferKey = 'voice_training_custom';
          } 

          const buff = musicVoiceTrainingBuffers[bufferKey];
          if (buff) {
            previewAudio(val, buff, 0, false);
          } 
        } 
     

        // 4) Efecto visual breve en el label
        const voiceTrainingLabel = document.getElementById('voice-training-label');
        voiceTrainingLabel.classList.add('feedback');
        setTimeout(() => {
          voiceTrainingLabel.classList.remove('feedback');
        }, 1000);

        // 5) Disparamos un “input” artificial en circle5
        const fakeInputEvent = new Event('input', { bubbles: true });
        inputC5.dispatchEvent(fakeInputEvent);
      }
    }
  });
});

      // Inputs file
      const musicUploadInput = this.shadowRoot.querySelector('#music-upload-input');
      const voiceTrainingUploadInput = this.shadowRoot.querySelector('#voice-training-upload-input');

      musicUploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          musicVoiceTrainingBuffers['music_custom'] = audioBuffer;
          currentMusic = 'music_custom';

          this.selectMusic('music_upload');
          saveSettingsToLocalStorage();

          if (isPlaying && !isPaused) {
            playMusic();
          }
        } catch (err) {
          console.error('Error subiendo archivo Music:', err);
          alert('No se pudo decodificar el archivo de audio para Music.');
        }
      });
      voiceTrainingUploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          musicVoiceTrainingBuffers['voice_training_custom'] = audioBuffer;
          currentVoiceTraining = 'voice_training_custom';

          this.selectVoiceTraining('voice_training_upload');
          saveSettingsToLocalStorage();

          if (isPlaying && !isPaused) {
            playVoiceTraining();
          } 
        } catch (err) {
          console.error('Error subiendo archivo Voice:', err);
          alert('No se pudo decodificar el archivo de audio para Voice Training.');
        }
      });
    }

    closeDropdown() {
      stopCurrentPreview();
      this.dropdownContent.classList.remove('show');
      if (window.__CURRENT_OPEN_DROPDOWN__ === this) {
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      }
    }
    closeAllOthers() {
      stopCurrentPreview();
      if (window.__CURRENT_OPEN_DROPDOWN__ && window.__CURRENT_OPEN_DROPDOWN__ !== this) {
        if (window.__CURRENT_OPEN_DROPDOWN__.closeDropdown) {
          window.__CURRENT_OPEN_DROPDOWN__.closeDropdown();
        }
        window.__CURRENT_OPEN_DROPDOWN__ = null;
      }
    }

    selectMusic(value) {
      // 1) marcar celdas
      this.dropdownItems.forEach(item => {
        const val = item.getAttribute('data-value');
        if (val && val.startsWith('music_')) {
          if (val === value) item.classList.add('selected');
          else item.classList.remove('selected');
        }
      });
      // 2) variable global
      if (value === 'music_upload') {
        currentMusic = 'music_custom';
      } else {
        currentMusic = value;
      }
      // 3) update button
      this.updateButtonText();
      // 4) play if needed
      if (isPlaying && !isPaused) {
        playMusic();
      }
    }

    selectVoiceTraining(value) {
      this.dropdownItems.forEach(item => {
        const val = item.getAttribute('data-value');
        if (val && val.startsWith('voice_training_')) {
          if (val === value) item.classList.add('selected');
          else item.classList.remove('selected');
        }
      });
      if (value === 'voice_training_upload') {
        currentVoiceTraining = 'voice_training_custom';
      } else {
        currentVoiceTraining = value;
      }
      this.updateButtonText();
      if (isPlaying && !isPaused) {
        playVoiceTraining();
      }
    }

    updateButtonText() {
      // Music
      let textMusic = 'None';
      const selMusic = this.shadowRoot.querySelector('.dropdown-item.selected[data-value^="music_"]');
      if (selMusic) {
        const val = selMusic.getAttribute('data-value');
        const img = selMusic.querySelector('img');
        if (val === 'music_upload') {
          textMusic = 'Custom';
        } else {
          textMusic = img ? img.getAttribute('alt') : 'Unknown';
        }
      }
      // Voice
      let textVoice = 'None';
      const selVoice = this.shadowRoot.querySelector('.dropdown-item.selected[data-value^="voice_training_"]');
      if (selVoice) {
        const val = selVoice.getAttribute('data-value');
        const img = selVoice.querySelector('img');
        if (val === 'voice_training_upload') {
          textVoice = 'Custom';
        } else {
          textVoice = img ? img.getAttribute('alt') : 'Unknown';
        }
      }
      this.dropdownButton.innerHTML = `
    <div class="button-text-container">
        <span>Music: <span class="selected-text truncate">${textMusic}</span></span> -
        <span>Voice: <span class="selected-text truncate">${textVoice}</span></span>
    </div>
    <span class="dropdown-arrow">▼</span>
`;
    }
  }

  customElements.define('music-voice-training-dropdown', MusicVoiceTrainingDropdown);

  
</script>


<script>
  class ThemeSelector extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });

      // Valor global de claridad (neutral = 50)
      this.globalClarity = 50;

      // Variables para almacenar datos del tema seleccionado para fondos
      this.origBg1 = null; 
      this.hueBg1 = null;  
      this.satBg1 = null;  
      this.origLBg1 = null;

      this.origBg2 = null;
      this.hueBg2 = null;
      this.satBg2 = null;
      this.origLBg2 = null;

      // Indica si actualmente estamos en modo "Load Image Only" (tema custom)
      this.isCustomMode = false;

      // Plantilla HTML/CSS interna del web component
      this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          font-family: sans-serif;
          margin: 10px 0 20px;
        }
        
        .theme-container {
          display: flex;
          gap: 12px;
          justify-content: center;
          align-items: center;
          flex-wrap: nowrap;
        }
        .theme-option {
          width: 15px;
          height: 15px;
          padding: 1px;
          border-radius: 50%;
          cursor: pointer;
          border: 2px solid transparent;
          transition: transform 0.3s ease, box-shadow 0.3s ease;
          position: relative;
          overflow: hidden;
          box-shadow: 0px 0px 35px rgba(255, 255, 255, 0.8);
        }
        .theme-option:hover {
          transform: scale(1.3);
          box-shadow: 0 0 10px rgba(255,255,255,0.6);
        }
        .theme-option:active::after {
          content: "";
          position: absolute;
          width: 100%;
          height: 100%;
          border-radius: 50%;
          top: 0;
          left: 0;
          background: rgba(255,255,255,0.3);
          animation: pulse 0.4s ease-out;
        }
        .theme-option.selected {
          transform: scale(1.2);
          box-shadow: 0 0 10px rgba(255,255,255,0.6);
        }
        @keyframes pulse {
          0% { transform: scale(1); opacity: 1; }
          100% { transform: scale(2); opacity: 0; }
        }
        
        .dial-container {
          display: flex;
          gap: 20px;
          justify-content: space-around;
          flex-wrap: nowrap;
          margin-top: 20px;
        }
        .dial {
          position: relative;
          width: 80px;
          height: 80px;
          border-radius: 50%;
          background: conic-gradient(#4CAF50 0%, #CDDC39 0%);
          display: flex;
          align-items: center;
          justify-content: center;
          user-select: none;
          touch-action: none;
          transition: background 0.2s;
          box-shadow: 0px 0px 35px rgba(255, 255, 255, 0.8);
        }
        .dial .value {
          font-size: 16px;
          color: rgba(255,255,255,0.0);
        }
        .dial .dial-label {
          position: absolute;
          top: -20px;
          font-size: 12px;
          width: 100%;
          text-align: center;
          color: rgba(0,0,0,0.6);
        }
        @media (max-width: 600px) {
          .dial {
            width: 40px;
            height: 40px;
          }
          .dial .value {
            font-size: 15px;
            color: rgba(255,255,255,0.0);
          }
          .dial .dial-label {
            font-size: 10px;
            top: -18px;
            color: var(--label-color, #00bcd4);
            opacity: 0.7; 
          }
        }
      </style>

      <div class="theme-container">

<div class="theme-option default"
  data-bg1="#464753"
  data-bg2="#04090c"
  data-menu1="rgba(0,0,0,0.0)"
  data-menu2="rgba(0,0,0,0.6)"
  data-slider-bg="#a180bf"
  data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/relaxing_river.jpg"
  data-animation="true"
  data-filter="hue-rotate(331deg)"
  data-label-color="#fcf8e2"
  data-knob-color="#187788"
  style="background: radial-gradient(circle, #464753, #04090c);"
  title="Custom Theme">
</div>

        <div class="theme-option" 
             data-bg1="#466c91" 
             data-bg2="#03080a" 
             data-menu1="rgba(0,0,0,0.0)" 
             data-menu2="rgba(0,0,0,0.6)"
             data-slider-bg="#1e89b3" 
             data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/iguazu.jpg"
             data-animation="true"
             data-filter="hue-rotate(0deg) contrast(120%)"
             data-label-color="#91e8f5"
             data-knob-color="#1e89b3"
             style="background: radial-gradient(circle, #466c91, #03080a);" 
             title="Blue"></div>

        <div class="theme-option" 
             data-bg1="#8f4691" 
             data-bg2="#03080a"  
             data-menu1="rgba(0,0,0,0.0)" 
             data-menu2="rgba(0,0,0,0.6)"
             data-slider-bg="#ad4b9b" 
             data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/yoga-hd-wallpaper.jpg"
             data-animation="false"
             data-filter="hue-rotate(120deg)"
             data-label-color="#1e89b3"
             data-knob-color="#ad4b9b"
             style="background: radial-gradient(circle, #8f4691, #03080a);" 
             title="Purple"></div>

        <div class="theme-option" 
             data-bg1="#395e3d" 
             data-bg2="#03080a"   
             data-menu1="rgba(0,0,0,0.0)" 
             data-menu2="rgba(0,0,0,0.6)"
             data-slider-bg="#97b01a" 
             data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/beach-island-landscape-natu.jpg"
             data-animation="false"
             data-filter="hue-rotate(210deg) contrast(120%)"
             data-label-color="#cdf9c1"
             data-knob-color="#97b01a"
             style="background: radial-gradient(circle, #395e3d, #03080a);" 
             title="Green"></div>

        <div class="theme-option" 
             data-bg1="#454652" 
             data-bg2="#03080a" 
             data-menu1="rgba(0,0,0,0.0)" 
             data-menu2="rgba(0,0,0,0.6)"
             data-slider-bg="#a180bf" 
             data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/relaxing_river.jpg"
             data-animation="true"
             data-filter="hue-rotate(50deg)"
             data-label-color="#ffffff"
             data-knob-color="#a180bf"
             style="background: radial-gradient(circle, #454652, #03080a);" 
             title="Magenta"></div>

        <div class="theme-option" 
             data-bg1="#d44613" 
             data-bg2="#03080a" 
             data-menu1="rgba(0,0,0,0.0)" 
             data-menu2="rgba(0,0,0,0.6)"
             data-slider-bg="#cfae1f" 
             data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/relaxing_butterfly.jpg"
             data-animation="false"
             data-filter="hue-rotate(190deg)"
             data-label-color="##95cc08"
             data-knob-color="#cfae1f"
             style="background: radial-gradient(circle, #d44613, #03080a);" 
             title="Orange"></div>

        <div class="theme-option" 
             data-bg1="#0b665a" 
             data-bg2="#03080a" 
             data-menu1="rgba(0,0,0,0.0)" 
             data-menu2="rgba(0,0,0,0.6)"
             data-slider-bg="#1ab060" 
             data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/320-x-320-yoga_thumbnail.jpg"
             data-animation="false"
             data-filter="hue-rotate(256deg)"
             data-label-color="#ffffff"
             data-knob-color="#1ab060"
             style="background: radial-gradient(circle, #0b665a, #03080a);" 
             title="Teal"></div>

        <!-- Tema final -->
        <div class="theme-option last-theme"
             data-bg1="#B8860B" 
             data-bg2="#8B0000" 
             data-menu1="rgba(0,0,0,0.0)" 
             data-menu2="rgba(0,0,0,0.6)"
             data-slider-bg="#c7304b"
             data-img="https://unmatrixlab.com/wp-content/uploads/2025/02/90sNY.jpeg"
             data-animation="false"
             data-filter="hue-rotate(130deg)"
             data-label-color="#95cc08"
             data-knob-color="#c7304b"
             style="background: radial-gradient(circle, #B8860B, #8B0000);" 
             title="Dusk Inferno"></div>

        <!-- Círculo para cargar imagen sin cambiar colores -->
        <div class="theme-option image-only-option"
             style="background: radial-gradient(circle, #FFFFFF, #C0C0C0);"
             title="Load Image Only"></div>
      </div>

      <div class="dial-container">
        <div class="dial" id="dial-bg1" data-param="bg1" data-min="0" data-max="360" style="--value: 0;">
          <span class="dial-label">Backg A</span>
          <span class="value">0</span>
        </div>
        <div class="dial" id="dial-bg2" data-param="bg2" data-min="0" data-max="360" style="--value: 0;">
          <span class="dial-label">Backg B</span>
          <span class="value">0</span>
        </div>
        <div class="dial" id="dial-clarity" data-param="clarity" data-min="0" data-max="100" style="--value: 50;">
          <span class="dial-label">Clarity</span>
          <span class="value">50</span>
        </div>
        <div class="dial" id="dial-filter" data-param="filter" data-min="0" data-max="760" style="--value: 0;">
          <span class="dial-label">Circle</span>
          <span class="value">0</span>
        </div>
        <div class="dial" id="dial-label-color" data-param="label-color" data-min="0" data-max="760" style="--value: 0;">
          <span class="dial-label">Text</span>
          <span class="value">0</span>
        </div>
        <div class="dial" id="dial-knob-color" data-param="knob-color" data-min="0" data-max="760" style="--value: 0;">
          <span class="dial-label">Knobs</span>
          <span class="value">0</span>
        </div>
      </div>
      `;
    }

    // Convierte HEX a objeto HSL
    hexToHSL(hex) {
      hex = hex.replace(/^#/, '');
      let r = parseInt(hex.substring(0, 2), 16) / 255;
      let g = parseInt(hex.substring(2, 4), 16) / 255;
      let b = parseInt(hex.substring(4, 6), 16) / 255;
      let max = Math.max(r, g, b);
      let min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return {
        h: Math.round(h * 360),
        s: Math.round(s * 100),
        l: Math.round(l * 100)
      };
    }

    // Convierte objeto HSL a HEX
    hslToHex(h, s, l) {
      s /= 100;
      l /= 100;
      let c = (1 - Math.abs(2 * l - 1)) * s;
      let x = c * (1 - Math.abs((h / 60) % 2 - 1));
      let m = l - c / 2;
      let r, g, b;
      if (h < 60) {
        r = c; g = x; b = 0;
      } else if (h < 120) {
        r = x; g = c; b = 0;
      } else if (h < 180) {
        r = 0; g = c; b = x;
      } else if (h < 240) {
        r = 0; g = x; b = c;
      } else if (h < 300) {
        r = c; g = 0; b = x;
      } else {
        r = c; g = 0; b = x;
      }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return "#" + [r, g, b].map(x => {
        let hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
    }

    // Calcula el color efectivo para el fondo indicado
    _getEffectiveColor(side) {
      if (side === 1) {
        let effectiveL = this.origLBg1 + (this.globalClarity - 50);
        effectiveL = Math.min(100, Math.max(0, effectiveL));
        return this.hslToHex(this.hueBg1, this.satBg1, effectiveL);
      } else {
        let effectiveL = this.origLBg2 + (this.globalClarity - 50);
        effectiveL = Math.min(100, Math.max(0, effectiveL));
        return this.hslToHex(this.hueBg2, this.satBg2, effectiveL);
      }
    }

   updateDial(dialElement, value) {
  let min = parseInt(dialElement.getAttribute('data-min'));
  let max = parseInt(dialElement.getAttribute('data-max'));
  dialElement.style.setProperty('--value', value);
  let percent = ((value - min) / (max - min)) * 100;
  dialElement.style.background = `conic-gradient(rgba(0,188,212,0.2) ${percent}%, rgba(221,221,221,0.5) ${percent}%)`;
  let valueSpan = dialElement.querySelector('.value');
  if (valueSpan) {
    valueSpan.textContent = value;
  }

  // Si el dial es para el color de texto, actualizamos --label-color
  if (dialElement.getAttribute('data-param') === 'label-color') {
    let hue = value % 360;
    // Se calcula la luminancia: a mayor valor, menor lightness (esto depende de cómo se desee el efecto)
    let lightness = 100 - (value * 95 / 760);
    const newLabelColor = this.hslToHex(hue, 83, lightness);
    document.documentElement.style.setProperty('--label-color', newLabelColor);
    localStorage.setItem('theme-label-color', newLabelColor);
    localStorage.setItem('theme-label-color-raw', value);
  }
}

    // Guarda en localStorage la configuración 'custom' (knobs, etc.) si estamos en modo custom
    storeCustomSettings() {
      // Sólo guarda si estamos en modo custom
      if (!this.isCustomMode) return;

      // Guardamos la imagen actual
      const lastImg = localStorage.getItem('theme-img');
      if (lastImg) {
        localStorage.setItem('last-custom-img', lastImg);
      }
      // Guardamos las tonalidades
      const hue1 = localStorage.getItem('theme-hue-bg1') || '0';
      const hue2 = localStorage.getItem('theme-hue-bg2') || '0';
      const clarity = localStorage.getItem('theme-clarity') || '50';
      const filter = localStorage.getItem('theme-filter') || 'none';
      const labelColor = localStorage.getItem('theme-label-color') || '#00bcd4';
      const labelRaw = localStorage.getItem('theme-label-color-raw') || '0';
      const knobColor = localStorage.getItem('theme-knob-color') || '#324e57';
      const knobRaw = localStorage.getItem('theme-knob-color-raw') || '0';
      const efBg1 = localStorage.getItem('theme-bg1') || '#08161c';
      const efBg2 = localStorage.getItem('theme-bg2') || '#03080a';

      localStorage.setItem('last-custom-hue-bg1', hue1);
      localStorage.setItem('last-custom-hue-bg2', hue2);
      localStorage.setItem('last-custom-clarity', clarity);
      localStorage.setItem('last-custom-filter', filter);
      localStorage.setItem('last-custom-label-color', labelColor);
      localStorage.setItem('last-custom-label-color-raw', labelRaw);
      localStorage.setItem('last-custom-knob-color', knobColor);
      localStorage.setItem('last-custom-knob-color-raw', knobRaw);
      localStorage.setItem('last-custom-bg1', efBg1);
      localStorage.setItem('last-custom-bg2', efBg2);
    }

    // Aplica la configuración 'custom' desde lo que tenemos en localStorage
    applyLastCustomTheme() {
      const lastImg = localStorage.getItem('last-custom-img');
      if (!lastImg) return; // Nada que hacer si no hay nada guardado

      // Leemos todo
      const hue1 = parseInt(localStorage.getItem('last-custom-hue-bg1') || '0', 10);
      const hue2 = parseInt(localStorage.getItem('last-custom-hue-bg2') || '0', 10);
      const clarity = parseInt(localStorage.getItem('last-custom-clarity') || '50', 10);
      const filter = localStorage.getItem('last-custom-filter') || 'none';
      const labelColor = localStorage.getItem('last-custom-label-color') || '#00bcd4';
      const labelRaw = parseInt(localStorage.getItem('last-custom-label-color-raw') || '0', 10);
      const knobColor = localStorage.getItem('last-custom-knob-color') || '#324e57';
      const knobRaw = parseInt(localStorage.getItem('last-custom-knob-color-raw') || '0', 10);
      const efBg1 = localStorage.getItem('last-custom-bg1') || '#08161c';
      const efBg2 = localStorage.getItem('last-custom-bg2') || '#03080a';

      // Aplicamos todo en la página
      this.hueBg1 = hue1;
      this.hueBg2 = hue2;
      this.globalClarity = clarity;

      // Para que el webcomponent recuerde "origBg1/origBg2" y sat/l
      // Al menos usa lo que venía guardado como "theme-orig-bg1/bg2" en algún momento,
      // o si no, le asignamos uno genérico
      // En modo custom no siempre definimos un color base, pero al menos
      // ajustemos la saturación y luminancia sacándolas de la conversión HSL
      let hsl1 = this.hexToHSL(efBg1);
      this.satBg1 = hsl1.s;
      this.origLBg1 = this._clampL(hsl1.l - (50 - clarity)); 
      let hsl2 = this.hexToHSL(efBg2);
      this.satBg2 = hsl2.s;
      this.origLBg2 = this._clampL(hsl2.l - (50 - clarity));

      document.documentElement.style.setProperty('--bg-color-1', efBg1);
      document.documentElement.style.setProperty('--bg-color-2', efBg2);
      document.body.style.background = `radial-gradient(circle, ${efBg1}, ${efBg2})`;

      document.documentElement.style.setProperty('--label-color', labelColor);
      document.documentElement.style.setProperty('--knob-color', knobColor);

      const largeCircle = document.querySelector('.unmatrix-lab-large-circle');
      if (largeCircle) {
        largeCircle.style.setProperty('--background-image', `url('${lastImg}')`);
        largeCircle.style.filter = filter;
      }

      // Actualizamos localStorage global (no confundir a la app)
      localStorage.setItem('theme-bg1', efBg1);
      localStorage.setItem('theme-bg2', efBg2);
      localStorage.setItem('theme-img', lastImg);
      localStorage.setItem('theme-filter', filter);
      localStorage.setItem('theme-label-color', labelColor);
      localStorage.setItem('theme-label-color-raw', labelRaw);
      localStorage.setItem('theme-knob-color', knobColor);
      localStorage.setItem('theme-knob-color-raw', knobRaw);
      localStorage.setItem('theme-hue-bg1', hue1);
      localStorage.setItem('theme-hue-bg2', hue2);
      localStorage.setItem('theme-clarity', clarity);

      // Actualizar diales
      this.updateDial(this.shadowRoot.getElementById('dial-bg1'), hue1);
      this.updateDial(this.shadowRoot.getElementById('dial-bg2'), hue2);
      this.updateDial(this.shadowRoot.getElementById('dial-clarity'), clarity);

      let match = filter.match(/hue-rotate\((\d+)deg\)/);
      let filterVal = 0;
      if (match) {
        filterVal = parseInt(match[1], 10);
      }
      this.updateDial(this.shadowRoot.getElementById('dial-filter'), filterVal);

      this.updateDial(this.shadowRoot.getElementById('dial-label-color'), labelRaw);
      this.updateDial(this.shadowRoot.getElementById('dial-knob-color'), knobRaw);

      // Mantenemos isCustomMode = true
      this.isCustomMode = true;
    }

    // Pequeño helper para no salir de 0..100
    _clampL(num) {
      if (num < 0) return 0;
      if (num > 100) return 100;
      return num;
    }

    connectedCallback() {
      const options = this.shadowRoot.querySelectorAll('.theme-option');
      const dialElements = this.shadowRoot.querySelectorAll('.dial');
      let startY, startValue;

      // Eventos en cada dial (movimiento de perilla)
      dialElements.forEach(dial => {
        dial.addEventListener('pointerdown', (e) => {
          startY = e.clientY;
          startValue = parseInt(getComputedStyle(dial).getPropertyValue('--value')) || 0;
          dial.setPointerCapture(e.pointerId);
        });

        dial.addEventListener('pointermove', (e) => {
          if (startY === undefined) return;
          let delta = startY - e.clientY;
          let change = Math.round(delta / 2);
          let min = parseInt(dial.getAttribute('data-min'));
          let max = parseInt(dial.getAttribute('data-max'));
          let newValue = Math.min(max, Math.max(min, startValue + change));
          this.updateDial(dial, newValue);

          const param = dial.getAttribute('data-param');
          if (param === 'bg1') {
            this.hueBg1 = newValue;
            localStorage.setItem('theme-hue-bg1', newValue);
            let efColor1 = this._getEffectiveColor(1);
            document.documentElement.style.setProperty('--bg-color-1', efColor1);
            document.body.style.background =
              `radial-gradient(circle, ${efColor1}, ${this._getEffectiveColor(2)})`;
            localStorage.setItem('theme-bg1', efColor1);

          } else if (param === 'bg2') {
            this.hueBg2 = newValue;
            localStorage.setItem('theme-hue-bg2', newValue);
            let efColor2 = this._getEffectiveColor(2);
            document.documentElement.style.setProperty('--bg-color-2', efColor2);
            document.body.style.background =
              `radial-gradient(circle, ${this._getEffectiveColor(1)}, ${efColor2})`;
            localStorage.setItem('theme-bg2', efColor2);

          } else if (param === 'clarity') {
            this.globalClarity = newValue;
            localStorage.setItem('theme-clarity', newValue);
            let efBg1 = this._getEffectiveColor(1);
            let efBg2 = this._getEffectiveColor(2);
            document.documentElement.style.setProperty('--bg-color-1', efBg1);
            document.documentElement.style.setProperty('--bg-color-2', efBg2);
            document.body.style.background =
              `radial-gradient(circle, ${efBg1}, ${efBg2})`;
            localStorage.setItem('theme-bg1', efBg1);
            localStorage.setItem('theme-bg2', efBg2);

          } else if (param === 'filter') {
            const largeCircle = document.querySelector('.unmatrix-lab-large-circle');
            if (largeCircle) {
              largeCircle.style.filter = `hue-rotate(${newValue}deg)`;
            }
            localStorage.setItem('theme-filter', `hue-rotate(${newValue}deg)`);

          } else if (param === 'label-color') {
            let hue = newValue % 360;
            let lightness = 100 - (newValue * 95 / 760);
            const newLabelColor = this.hslToHex(hue, 83, lightness);
            document.documentElement.style.setProperty('--label-color', newLabelColor);
            localStorage.setItem('theme-label-color', newLabelColor);
            localStorage.setItem('theme-label-color-raw', newValue);

          } else if (param === 'knob-color') {
            let hue = newValue % 360;
            let lightness = 100 - (newValue * 95 / 760);
            const newKnobColor = this.hslToHex(hue, 70, lightness);
            document.documentElement.style.setProperty('--knob-color', newKnobColor);
            localStorage.setItem('theme-knob-color', newKnobColor);
            localStorage.setItem('theme-knob-color-raw', newValue);
          }
        });

        dial.addEventListener('pointerup', () => {
          // Cuando se termina de arrastrar, si estamos en modo custom, almacenamos
          this.storeCustomSettings();
          startY = undefined;
        });
      });

      // Al clickar en un tema
      options.forEach(option => {
        option.addEventListener('click', () => {
          // Si es el círculo "Load Image Only" => Modo Custom
          if (option.classList.contains('image-only-option')) {
            this.isCustomMode = true; // Entramos en modo custom

            const largeCircle = document.querySelector('.unmatrix-lab-large-circle');
            if (!largeCircle) return;

            // Creamos cartel flotante
            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.top = '50%';
            container.style.left = '50%';
            container.style.transform = 'translate(-50%, -50%)';
            container.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
            container.style.padding = '20px';
            container.style.borderRadius = '10px';
            container.style.zIndex = '9999';
            container.style.color = '#fff';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.gap = '10px';
            container.style.alignItems = 'center';
            container.style.minWidth = '300px';

            const textLabel = document.createElement('p');
            textLabel.textContent = 'Load Image';
            textLabel.style.textAlign = 'center';
            textLabel.style.margin = '0'; 
            textLabel.style.fontSize = '20px'; 
            textLabel.style.fontWeight = '500'; 
            container.appendChild(textLabel);
            

            const btnLocal = document.createElement('button');
            btnLocal.textContent = 'Local 📷';
            btnLocal.style.width = '100%';
            btnLocal.style.padding = '12px ';   
            btnLocal.style.fontSize = '16px'; 
            btnLocal.style.fontWeight = '600'; 
            btnLocal.style.color = '#000';      
            container.appendChild(btnLocal);

            const btnWeb = document.createElement('button');
            btnWeb.textContent = 'Web 🌐';
            btnWeb.style.width = '100%';
            btnWeb.style.padding = '12px ';   
            btnWeb.style.fontSize = '16px'; 
            btnWeb.style.fontWeight = '600'; 
            btnWeb.style.color = '#000';  
            container.appendChild(btnWeb);

            // Botón para recuperar ultimo custom
            const btnRecover = document.createElement('button');
            btnRecover.textContent = 'Recover Last ↩️';
            btnRecover.style.width = '100%';
            btnRecover.style.padding = '12px ';
            btnRecover.style.fontSize = '16px'; 
            btnRecover.style.fontWeight = '600'; 
            btnRecover.style.color = '#000';

            // Si no existe algo guardado custom, ocultamos el botón
            if (!localStorage.getItem('last-custom-img')) {
              btnRecover.style.display = 'none';
            }
            container.appendChild(btnRecover);

            const btnCancel = document.createElement('button');
            btnCancel.textContent = 'Cancel';
            btnCancel.style.width = '100%';
            btnCancel.style.padding = '12px ';   
            btnCancel.style.fontSize = '16px'; 
            btnCancel.style.fontWeight = '600'; 
            btnCancel.style.color = '#0672bf';
            container.appendChild(btnCancel);
            

            document.body.appendChild(container);

            const removeContainer = () => {
              if (container.parentNode) {
                container.parentNode.removeChild(container);
              }
            };

            // Botón LOCAL
            btnLocal.addEventListener('click', () => {
              const fileInput = document.createElement('input');
              fileInput.type = 'file';
              // Acepta cualquier tipo de imagen
              fileInput.accept = 'image/*';
              fileInput.style.display = 'none';
              container.appendChild(fileInput);

              fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                  // ----------- Límite de 5MB para archivo local -----------
                  if (file.size > 7 * 1024 * 1024) {
                    alert('La imagen excede 5MB');
                    removeContainer();
                    return;
                  }
                  // --------------------------------------------------------
                  const reader = new FileReader();
                  reader.onload = (event) => {
                    const dataURL = event.target.result;

                    // Redimensionar en canvas si excede cierto tamaño
                    const image = new Image();
                    image.onload = () => {
                      let maxDim = 1200;
                      let w = image.width;
                      let h = image.height;
                      if (w > maxDim || h > maxDim) {
                        let ratio = Math.min(maxDim / w, maxDim / h);
                        w = Math.round(w * ratio);
                        h = Math.round(h * ratio);
                      }
                      const canvas = document.createElement('canvas');
                      canvas.width = w;
                      canvas.height = h;
                      const ctx = canvas.getContext('2d');
                      ctx.drawImage(image, 0, 0, w, h);

                      // ---- Comprimir en JPEG con calidad 0.7 ----
                      const newDataURL = canvas.toDataURL('image/jpeg', 0.7);
                      largeCircle.style.setProperty('--background-image', `url('${newDataURL}')`);
                      // -------------------------------------------

                      const currentFilter = localStorage.getItem('theme-filter') || 'none';
                      largeCircle.style.filter = currentFilter;
                      localStorage.setItem('theme-img', newDataURL);

                      // Guardar en localStorage la configuración actual, modo custom
                      this.storeCustomSettings();
                    };
                    image.src = dataURL;
                  };
                  reader.readAsDataURL(file);
                }
                removeContainer();
              });

              fileInput.click();
            });

            // Botón WEB (con verificación de tamaño por HEAD)
            btnWeb.addEventListener('click', async () => {
              const customURL = prompt('Enter the image URL:');
              if (customURL) {
                try {
                  let response = await fetch(customURL, { method: 'HEAD' });
                  let size = response.headers.get('Content-Length');
                  if (size && parseInt(size, 10) > 5 * 1024 * 1024) {
                    alert('La imagen excede 5MB');
                    removeContainer();
                    return;
                  }
                } catch (e) {
                  console.log(e);
                }
                largeCircle.style.setProperty('--background-image', `url('${customURL}')`);
                const currentFilter = localStorage.getItem('theme-filter') || 'none';
                largeCircle.style.filter = currentFilter;
                localStorage.setItem('theme-img', customURL);

                // Guardar en localStorage la configuración actual, modo custom
                this.storeCustomSettings();
              }
              removeContainer();
            });

            // Botón RECOVER LAST CUSTOM
            btnRecover.addEventListener('click', () => {
              removeContainer();
              this.applyLastCustomTheme();
            });

            btnCancel.addEventListener('click', () => {
              removeContainer();
            });

          } else {
            // Selecciona un tema normal
            this.isCustomMode = false;  // Salimos de modo custom
            options.forEach(o => o.classList.remove('selected'));
            option.classList.add('selected');

            const bg1 = option.getAttribute('data-bg1');
            const bg2 = option.getAttribute('data-bg2');
            const img = option.getAttribute('data-img');
            const animationEnabled = option.getAttribute('data-animation') === "true";
            const menu1 = option.getAttribute('data-menu1');
            const menu2 = option.getAttribute('data-menu2');
            const filter = option.getAttribute('data-filter');
            const sliderBg = option.getAttribute('data-slider-bg');
            const labelColor = option.getAttribute('data-label-color');
            const knobColor = option.getAttribute('data-knob-color');

            this.origBg1 = bg1;
            let hsl1 = this.hexToHSL(bg1);
            this.hueBg1 = hsl1.h;
            this.satBg1 = hsl1.s;
            this.origLBg1 = hsl1.l;

            this.origBg2 = bg2;
            let hsl2 = this.hexToHSL(bg2);
            this.hueBg2 = hsl2.h;
            this.satBg2 = hsl2.s;
            this.origLBg2 = hsl2.l;

            localStorage.setItem('theme-orig-bg1', bg1);
            localStorage.setItem('theme-orig-bg2', bg2);
            localStorage.setItem('theme-hue-bg1', this.hueBg1);
            localStorage.setItem('theme-hue-bg2', this.hueBg2);

            this.globalClarity = 50;
            localStorage.setItem('theme-clarity', 50);

            if (labelColor) {
              document.documentElement.style.setProperty('--label-color', labelColor);
              localStorage.setItem('theme-label-color', labelColor);
              let hslLabel = this.hexToHSL(labelColor);
              localStorage.setItem('theme-label-color-raw', hslLabel.h);
            }

            if (knobColor) {
              document.documentElement.style.setProperty('--knob-color', knobColor);
              localStorage.setItem('theme-knob-color', knobColor);
              let hslKnob = this.hexToHSL(knobColor);
              localStorage.setItem('theme-knob-color-raw', hslKnob.h);
            }

            let efBg1 = this._getEffectiveColor(1);
            let efBg2 = this._getEffectiveColor(2);

            document.documentElement.style.setProperty('--bg-color-1', efBg1);
            document.documentElement.style.setProperty('--bg-color-2', efBg2);
            document.body.style.background =
              `radial-gradient(circle, ${efBg1}, ${efBg2})`;

            document.documentElement.style.setProperty('--menu-bg-1', menu1);
            document.documentElement.style.setProperty('--menu-bg-2', menu2);

            const largeCircle = document.querySelector('.unmatrix-lab-large-circle');
            if (largeCircle) {
              largeCircle.style.setProperty('--background-image', `url('${img}')`);
              largeCircle.style.filter = filter;
            }
            localStorage.setItem('theme-img', img);
            localStorage.setItem('theme-filter', filter);

            if (sliderBg) {
              document.documentElement.style.setProperty('--slider-bg', sliderBg);
              localStorage.setItem('theme-slider-bg', sliderBg);
            }

            const birds = document.querySelectorAll('.bird-container');
            birds.forEach(bird => {
              bird.style.opacity = animationEnabled ? '1' : '0';
            });

            localStorage.setItem('theme-bg1', efBg1);
            localStorage.setItem('theme-bg2', efBg2);
            localStorage.setItem('theme-animation', animationEnabled);
            localStorage.setItem('theme-menu1', menu1);
            localStorage.setItem('theme-menu2', menu2);

            // Actualiza diales
            this.updateDial(this.shadowRoot.getElementById('dial-bg1'), this.hueBg1);
            this.updateDial(this.shadowRoot.getElementById('dial-bg2'), this.hueBg2);
            this.updateDial(this.shadowRoot.getElementById('dial-clarity'), this.globalClarity);

            let filterVal = 0;
            const match = filter.match(/hue-rotate\((\d+)deg\)/);
            if (match) {
              filterVal = parseInt(match[1], 10);
            }
            this.updateDial(this.shadowRoot.getElementById('dial-filter'), filterVal);

            if (localStorage.getItem('theme-label-color-raw')) {
              let storedRaw = parseInt(localStorage.getItem('theme-label-color-raw'), 10);
              this.updateDial(this.shadowRoot.getElementById('dial-label-color'), storedRaw);
            } else if (labelColor) {
              let hslLbl = this.hexToHSL(labelColor);
              this.updateDial(this.shadowRoot.getElementById('dial-label-color'), hslLbl.h);
            }

            if (localStorage.getItem('theme-knob-color-raw')) {
              let storedKnobRaw = parseInt(localStorage.getItem('theme-knob-color-raw'), 10);
              this.updateDial(this.shadowRoot.getElementById('dial-knob-color'), storedKnobRaw);
            } else if (knobColor) {
              let hslKnob = this.hexToHSL(knobColor);
              this.updateDial(this.shadowRoot.getElementById('dial-knob-color'), hslKnob.h);
            }
          }
        });
      });

      // Recuperar del localStorage (si existía un tema ya elegido con anterioridad)
      const storedBg1 = localStorage.getItem('theme-bg1');
      const storedBg2 = localStorage.getItem('theme-bg2');
      const storedImg = localStorage.getItem('theme-img');
      const storedAnimation = localStorage.getItem('theme-animation') === "true";
      const storedMenu1 = localStorage.getItem('theme-menu1');
      const storedMenu2 = localStorage.getItem('theme-menu2');
      const storedFilter = localStorage.getItem('theme-filter');
      const storedSliderBg = localStorage.getItem('theme-slider-bg');
      const storedOrigBg1 = localStorage.getItem('theme-orig-bg1');
      const storedOrigBg2 = localStorage.getItem('theme-orig-bg2');
      const storedHueBg1 = localStorage.getItem('theme-hue-bg1');
      const storedHueBg2 = localStorage.getItem('theme-hue-bg2');
      const storedClarity = localStorage.getItem('theme-clarity');
      const storedKnobColor = localStorage.getItem('theme-knob-color');

      if (storedBg1 && storedBg2 && storedImg) {
        document.documentElement.style.setProperty('--bg-color-1', storedBg1);
        document.documentElement.style.setProperty('--bg-color-2', storedBg2);
        document.body.style.background = `radial-gradient(circle, ${storedBg1}, ${storedBg2})`;

        const largeCircle = document.querySelector('.unmatrix-lab-large-circle');
        if (largeCircle) {
          largeCircle.style.setProperty('--background-image', `url('${storedImg}')`);
          largeCircle.style.filter = storedFilter;
        }
        if (storedMenu1 && storedMenu2) {
          document.documentElement.style.setProperty('--menu-bg-1', storedMenu1);
          document.documentElement.style.setProperty('--menu-bg-2', storedMenu2);
        }
        if (storedSliderBg) {
          document.documentElement.style.setProperty('--slider-bg', storedSliderBg);
        }

        const birds = document.querySelectorAll('.bird-container');
        birds.forEach(bird => {
          bird.style.opacity = storedAnimation ? '1' : '0';
        });

        if (storedOrigBg1 && storedOrigBg2) {
          this.origBg1 = storedOrigBg1;
          let hsl1 = this.hexToHSL(storedOrigBg1);
          this.hueBg1 = storedHueBg1 ? parseInt(storedHueBg1, 10) : hsl1.h;
          this.satBg1 = hsl1.s;
          this.origLBg1 = hsl1.l;

          this.origBg2 = storedOrigBg2;
          let hsl2 = this.hexToHSL(storedOrigBg2);
          this.hueBg2 = storedHueBg2 ? parseInt(storedHueBg2, 10) : hsl2.h;
          this.satBg2 = hsl2.s;
          this.origLBg2 = hsl2.l;
        }

        if (storedClarity) {
          this.globalClarity = parseInt(storedClarity, 10);
        }

        if (storedKnobColor) {
          document.documentElement.style.setProperty('--knob-color', storedKnobColor);
        }

        // Actualiza diales
        this.updateDial(this.shadowRoot.getElementById('dial-bg1'), this.hueBg1);
        this.updateDial(this.shadowRoot.getElementById('dial-bg2'), this.hueBg2);
        this.updateDial(this.shadowRoot.getElementById('dial-clarity'), this.globalClarity);

        let filterVal = 0;
        const m = storedFilter ? storedFilter.match(/hue-rotate\((\d+)deg\)/) : null;
        if (m) {
          filterVal = parseInt(m[1], 10);
        }
        this.updateDial(this.shadowRoot.getElementById('dial-filter'), filterVal);

        let labelValue = 0;
        if (localStorage.getItem('theme-label-color-raw')) {
          labelValue = parseInt(localStorage.getItem('theme-label-color-raw'), 10);
        } else if (localStorage.getItem('theme-label-color')) {
          let hsl = this.hexToHSL(localStorage.getItem('theme-label-color'));
          labelValue = hsl.h;
        }
        this.updateDial(this.shadowRoot.getElementById('dial-label-color'), labelValue);

        let knobValue = 0;
        if (localStorage.getItem('theme-knob-color-raw')) {
          knobValue = parseInt(localStorage.getItem('theme-knob-color-raw'), 10);
        } else if (storedKnobColor) {
          let hslKnob = this.hexToHSL(storedKnobColor);
          knobValue = hslKnob.h;
        }
        this.updateDial(this.shadowRoot.getElementById('dial-knob-color'), knobValue);

        if (localStorage.getItem('theme-label-color')) {
          document.documentElement.style.setProperty('--label-color', localStorage.getItem('theme-label-color'));
        }

        // Selecciona la opción de tema guardada, si coincide
        let foundOption = false;
        options.forEach(option => {
          if (
            option.getAttribute('data-bg1') === storedOrigBg1 &&
            option.getAttribute('data-bg2') === storedOrigBg2 &&
            option.getAttribute('data-img') === storedImg
          ) {
            option.classList.add('selected');
            foundOption = true;
          } else {
            option.classList.remove('selected');
          }
        });

        // Si no encontramos un tema que coincida (puede ser "Load Image Only"), no dejamos ninguno
        // seleccionado formalmente. Podría ser el caso custom. 
        // (No es obligatorio, pero es la forma de no enredar la interfaz).
        if (!foundOption) {
          options.forEach(o => o.classList.remove('selected'));
        }
      } else {
        // Si no había un tema guardado, seleccionamos el tema default
        const defaultOption = this.shadowRoot.querySelector('.theme-option.default');
        if (defaultOption) {
          defaultOption.click();
        }
      }
    }
  }
  customElements.define('theme-selector', ThemeSelector);
</script>


<!-- ======== LÓGICA PARA LOS FADERS Y MUTEO (versión adaptada) ======== -->
<script>
  const masterFader         = document.getElementById('master-fader');
  const gongFader           = document.getElementById('gong-fader');
  const gongFinalFader      = document.getElementById('gong-final-fader');
  const ambient1Fader       = document.getElementById('ambient1-fader');
  const ambient2Fader       = document.getElementById('ambient2-fader');
  const musicFader          = document.getElementById('music-fader');
  const voiceTrainingFader  = document.getElementById('voice-training-fader');

  // === EVENTOS "input" EN LOS FADERS ===
  // Master usa escala logarítmica
  masterFader.addEventListener('input', () => {
    const normalizedValue = masterFader.value / 100;
    const logValue = Math.pow(normalizedValue, 2);
    if (!isMasterMuted && masterGain) {
      masterGain.gain.value = logValue;
    }
    saveSettingsToLocalStorage();
  });

  // Gong (Chime)
  gongFader.addEventListener('input', () => {
    const v = gongFader.value / 100;
    if (!isGongMuted && gongGain) {
      gongGain.gain.value = v;
    }
      // -- ¡NUEVO! Si hay preview "gong" sonando, actualizamos su volumen en vivo
  if (currentPreviewSource && currentPreviewItem && currentPreviewItem.startsWith('gong')) {
    currentPreviewGain.gain.value = v;
  }
    saveSettingsToLocalStorage();
  });

  // Gong Final
  gongFinalFader.addEventListener('input', () => {
    const v = gongFinalFader.value / 100;
    if (!isGongFinalMuted && gongFinalGain) {
      gongFinalGain.gain.value = v;
    }
      // -- ¡NUEVO! Si hay preview "final_gong" sonando, lo afectamos
  if (currentPreviewSource && currentPreviewItem && currentPreviewItem.startsWith('final_gong')) {
    currentPreviewGain.gain.value = v;
  }
    saveSettingsToLocalStorage();
  });

  // AMBIENT 1 => Usar ambient1FaderGain en vez de ambient1Gain
  ambient1Fader.addEventListener('input', () => {
    const v = ambient1Fader.value / 100;
    if (!isAmbient1Muted && ambient1FaderGain) {
      ambient1FaderGain.gain.value = v;
    }
     // -- NUEVO: preview
  if (currentPreviewSource && currentPreviewItem && currentPreviewItem.startsWith('ambient1')) {
    currentPreviewGain.gain.value = v;
  }
    saveSettingsToLocalStorage();
  });

  // AMBIENT 2 => Usar ambient2FaderGain
  ambient2Fader.addEventListener('input', () => {
    const v = ambient2Fader.value / 100;
    if (!isAmbient2Muted && ambient2FaderGain) {
      ambient2FaderGain.gain.value = v;
    }

  if (currentPreviewSource && currentPreviewItem && currentPreviewItem.startsWith('ambient2')) {
    currentPreviewGain.gain.value = v;
  }
    saveSettingsToLocalStorage();
  });

  // MUSIC => Usar musicFaderGain
  musicFader.addEventListener('input', () => {
    const v = musicFader.value / 100;
    if (!isMusicMuted && musicFaderGain) {
      musicFaderGain.gain.value = v;
    }
      if (currentPreviewSource && currentPreviewItem && currentPreviewItem.startsWith('music')) {
    currentPreviewGain.gain.value = v;
  }
    saveSettingsToLocalStorage();
  });

  // VOICE TRAINING (solo un nodo de ganancia, sin automatización)
  voiceTrainingFader.addEventListener('input', () => {
    const v = voiceTrainingFader.value / 100;
    if (!isVoiceTrainingMuted && voiceTrainingGain) {
      voiceTrainingGain.gain.value = v;
    }
      if (currentPreviewSource && currentPreviewItem && currentPreviewItem.startsWith('voice_training')) {
    currentPreviewGain.gain.value = v;
  }

    saveSettingsToLocalStorage();
  });


  // === MANEJO DE DROPDOWNS PARA GONG, AMBIENTES, MÚSICA, ETC. ===
  const gongDropdown = document.querySelector('gong-dropdown');
  gongDropdown.addEventListener('gongChange', (e) => {
    currentGong = e.detail.gong;
  });
  gongDropdown.addEventListener('finalGongChange', (e) => {
    currentFinalGong = e.detail.finalGong;
    if (currentFinalGong !== 'none_final') {
      playFinalGong();
    }
  });

  const ambientDropdown = document.querySelector('ambient-dropdown');
  ambientDropdown.addEventListener('ambient1Change', (e) => {
    currentAmbient1 = e.detail.ambient1;
    if (isPlaying && !isPaused) {
      playAmbient1();
    }
  });
  ambientDropdown.addEventListener('ambient2Change', (e) => {
    currentAmbient2 = e.detail.ambient2;
    if (isPlaying && !isPaused) {
      playAmbient2();
    }
  });

  const musicVoiceTrainingDropdown = document.querySelector('music-voice-training-dropdown');
  musicVoiceTrainingDropdown.addEventListener('musicChange', (e) => {
    currentMusic = e.detail.music;
    if (isPlaying && !isPaused) {
      playMusic();
    }
  });
  musicVoiceTrainingDropdown.addEventListener('voiceTrainingChange', (e) => {
    currentVoiceTraining = e.detail.voiceTraining;
    if (isPlaying && !isPaused) {
      playVoiceTraining();
    }
    // Ajuste de duración según track de voiceTraining
    if (currentVoiceTraining !== 'voice_training_none' && musicVoiceTrainingBuffers[currentVoiceTraining]) {
      const trackDuration = musicVoiceTrainingBuffers[currentVoiceTraining].duration;
      const totalSessionSec = trackDuration + 120;
      const totalSessionMin = Math.ceil(totalSessionSec / 60);
      inputC5.value = totalSessionMin;
      updateLargeCircle();
      saveSettingsToLocalStorage();
    }
  });


  // === BOTONES MUTE ===
  const muteButtons = document.querySelectorAll('.mute-button');
  muteButtons.forEach(button => {
    button.addEventListener('click', () => {
      const channel = button.getAttribute('data-channel');
      toggleMute(channel, button);
    });
  });

  /**
   * Función para togglear mute
   * - Master => masterGain
   * - Gong Final => gongFinalGain
   * - Music => musicFaderGain
   * - Voice => voiceTrainingGain
   * - Ambient 1 => ambient1FaderGain
   * - Ambient 2 => ambient2FaderGain
   * - Gong => gongGain
   */


  
  function toggleMute(channel, button, forceMute = false) {
    if (channel === 'master') {
      if (forceMute) {
        isMasterMuted = true;
        masterGain.gain.value = 0;
        button.textContent = '🔇';
        button.classList.add('muted');
      } else {
        if (!isMasterMuted) {
          isMasterMuted = true;
          masterGain.gain.value = 0;
          button.textContent = '🔇';
          button.classList.add('muted');
        } else {
          isMasterMuted = false;
          const normalizedValue = masterFader.value / 100;
          const logValue = Math.pow(normalizedValue, 2);
          masterGain.gain.value = logValue;
          button.textContent = '🔈';
          button.classList.remove('muted');
        }
      }

    } else if (channel === 'gong_final') {
      if (forceMute) {
        isGongFinalMuted = true;
        gongFinalGain.gain.value = 0;
        button.textContent = '🔇';
        button.classList.add('muted');
      } else {
        if (!isGongFinalMuted) {
          isGongFinalMuted = true;
          gongFinalGain.gain.value = 0;
          button.textContent = '🔇';
          button.classList.add('muted');
        } else {
          isGongFinalMuted = false;
          gongFinalGain.gain.value = gongFinalFader.value / 100;
          button.textContent = '🔈';
          button.classList.remove('muted');
        }
      }

    } else if (channel === 'music') {
      // Ahora es musicFaderGain (no musicGain)
      if (forceMute) {
        isMusicMuted = true;
        musicFaderGain.gain.value = 0;
        button.textContent = '🔇';
        button.classList.add('muted');
      } else {
        if (!isMusicMuted) {
          isMusicMuted = true;
          musicFaderGain.gain.value = 0;
          button.textContent = '🔇';
          button.classList.add('muted');
        } else {
          isMusicMuted = false;
          musicFaderGain.gain.value = musicFader.value / 100;
          button.textContent = '🔈';
          button.classList.remove('muted');
        }
      }

    } else if (channel === 'voice-training') {
      // Voice training sigue con un solo nodo
      if (forceMute) {
        isVoiceTrainingMuted = true;
        voiceTrainingGain.gain.value = 0;
        button.textContent = '🔇';
        button.classList.add('muted');
      } else {
        if (!isVoiceTrainingMuted) {
          isVoiceTrainingMuted = true;
          voiceTrainingGain.gain.value = 0;
          button.textContent = '🔇';
          button.classList.add('muted');
        } else {
          isVoiceTrainingMuted = false;
          voiceTrainingGain.gain.value = voiceTrainingFader.value / 100;
          button.textContent = '🔈';
          button.classList.remove('muted');
        }
      }

    } else {
      // Gong, Ambient1, Ambient2
      let gainNode, fader;

      switch (channel) {
        case 'gong':
          gainNode = gongGain;
          fader = gongFader;
          break;
        case 'ambient1':
          // Aquí se cambia a ambient1FaderGain
          gainNode = ambient1FaderGain;
          fader = ambient1Fader;
          break;
        case 'ambient2':
          gainNode = ambient2FaderGain;
          fader = ambient2Fader;
          break;
      }
      if (!gainNode || !fader) return;

      if (channel === 'gong') {
        if (forceMute) {
          isGongMuted = true;
          gainNode.gain.value = 0;
          button.textContent = '🔇';
          button.classList.add('muted');
        } else {
          if (!isGongMuted) {
            isGongMuted = true;
            gainNode.gain.value = 0;
            button.textContent = '🔇';
            button.classList.add('muted');
          } else {
            isGongMuted = false;
            gainNode.gain.value = fader.value / 100;
            button.textContent = '🔈';
            button.classList.remove('muted');
          }
        }
      } else if (channel === 'ambient1') {
        if (forceMute) {
          isAmbient1Muted = true;
          gainNode.gain.value = 0;
          button.textContent = '🔇';
          button.classList.add('muted');
        } else {
          if (!isAmbient1Muted) {
            isAmbient1Muted = true;
            gainNode.gain.value = 0;
            button.textContent = '🔇';
            button.classList.add('muted');
          } else {
            isAmbient1Muted = false;
            gainNode.gain.value = fader.value / 100;
            button.textContent = '🔈';
            button.classList.remove('muted');
          }
        }
      } else if (channel === 'ambient2') {
        if (forceMute) {
          isAmbient2Muted = true;
          gainNode.gain.value = 0;
          button.textContent = '🔇';
          button.classList.add('muted');
        } else {
          if (!isAmbient2Muted) {
            isAmbient2Muted = true;
            gainNode.gain.value = 0;
            button.textContent = '🔇';
            button.classList.add('muted');
          } else {
            isAmbient2Muted = false;
            gainNode.gain.value = fader.value / 100;
            button.textContent = '🔈';
            button.classList.remove('muted');
          }
        }
      }
    }
    saveSettingsToLocalStorage();
  }


  // === REANUDAR audioContext si está suspendido (al volver de "pageshow") ===
  function resumeAudio() {
    if (!audioContext) return;
    if (audioContext.state !== 'suspended') return;
    if (!isPlaying) return;
    if (isPaused) return;
    audioContext.resume()
      .then(() => {
        if (isPlaying && !isPaused) {
          playAmbient1();
          playAmbient2();
          playMusic();
          playVoiceTraining();
        }
      })
      .catch(err => {
        console.error('Error al reanudar audioContext:', err);
      });
  }
  window.addEventListener('pageshow', (event) => {
    if (event.persisted) {
      resumeAudio();
    }
  });


  // === SINCRONIZACIÓN DE SLIDERS ENTRE MENÚS y FADERS PRINCIPALES ===
  // Ejemplo con <gong-dropdown>
  window.addEventListener('DOMContentLoaded', () => {
    const gongDropdownElem = document.querySelector('gong-dropdown');
    setTimeout(() => {
      const gongFaderMenu      = gongDropdownElem.shadowRoot.querySelector('#gong-fader-menu');
      const gongFinalFaderMenu = gongDropdownElem.shadowRoot.querySelector('#gong-final-fader-menu');

      // 1) Ajustar el menú según el slider principal
      gongFaderMenu.value      = gongFader.value;
      gongFinalFaderMenu.value = gongFinalFader.value;

      // 2) Si mueves el slider del menú => actualizamos el principal
      gongFaderMenu.addEventListener('input', (e) => {
        gongFader.value = e.target.value;
        gongFader.dispatchEvent(new Event('input'));
      });
      gongFinalFaderMenu.addEventListener('input', (e) => {
        gongFinalFader.value = e.target.value;
        gongFinalFader.dispatchEvent(new Event('input'));
      });

      // 3) Si mueves el slider principal => actualizamos el menú
      gongFader.addEventListener('input', (e) => {
        gongFaderMenu.value = e.target.value;
      });
      gongFinalFader.addEventListener('input', (e) => {
        gongFinalFaderMenu.value = e.target.value;
      });
    }, 300);
  });

  // Ejemplo con <ambient-dropdown>
  window.addEventListener('DOMContentLoaded', () => {
    const ambientDropdownElem = document.querySelector('ambient-dropdown');
    setTimeout(() => {
      const ambient1FaderMenu = ambientDropdownElem.shadowRoot.querySelector('#ambient1-fader-menu');
      const ambient2FaderMenu = ambientDropdownElem.shadowRoot.querySelector('#ambient2-fader-menu');

      const ambient1Fader = document.getElementById('ambient1-fader');
      const ambient2Fader = document.getElementById('ambient2-fader');

      // 1) Ajustar menú según slider principal
      ambient1FaderMenu.value = ambient1Fader.value;
      ambient2FaderMenu.value = ambient2Fader.value;

      // 2) Menú => Principal
      ambient1FaderMenu.addEventListener('input', (e) => {
        ambient1Fader.value = e.target.value;
        ambient1Fader.dispatchEvent(new Event('input'));
      });
      ambient2FaderMenu.addEventListener('input', (e) => {
        ambient2Fader.value = e.target.value;
        ambient2Fader.dispatchEvent(new Event('input'));
      });

      // 3) Principal => Menú
      ambient1Fader.addEventListener('input', (e) => {
        ambient1FaderMenu.value = e.target.value;
      });
      ambient2Fader.addEventListener('input', (e) => {
        ambient2FaderMenu.value = e.target.value;
      });
    }, 300);
  });


window.addEventListener('DOMContentLoaded', () => {
  // 1) Esperar a que <music-voice-training-dropdown> exista en el DOM
  const mvDropdownElem = document.querySelector('music-voice-training-dropdown');

  setTimeout(() => {
    // 2) Dentro del shadowRoot, acceder a los faders del menú
    const musicFaderMenu = mvDropdownElem.shadowRoot.querySelector('#music-fader-menu');
    const voiceTrainingFaderMenu = mvDropdownElem.shadowRoot.querySelector('#voice-training-fader-menu');

    // 3) Referencias a los faders principales (fuera del menú)
    const musicFader = document.getElementById('music-fader');
    const voiceTrainingFader = document.getElementById('voice-training-fader');

    // ---------------------------------------------------------
    // A) Ajustar valores iniciales en el menú según los faders principales
    // ---------------------------------------------------------
    musicFaderMenu.value = musicFader.value;
    voiceTrainingFaderMenu.value = voiceTrainingFader.value;

    // ---------------------------------------------------------
    // B) Cuando se mueva el fader del MENÚ, actualizamos el PRINCIPAL
    // ---------------------------------------------------------
    musicFaderMenu.addEventListener('input', (e) => {
      musicFader.value = e.target.value;
      // Disparamos manualmente el evento “input” para que se ejecute la misma lógica (volumen, localStorage, etc.)
      musicFader.dispatchEvent(new Event('input'));
    });

    voiceTrainingFaderMenu.addEventListener('input', (e) => {
      voiceTrainingFader.value = e.target.value;
      voiceTrainingFader.dispatchEvent(new Event('input'));
    });

    // ---------------------------------------------------------
    // C) Cuando se mueva el fader PRINCIPAL, actualizamos el MENÚ
    // ---------------------------------------------------------
    musicFader.addEventListener('input', (e) => {
      musicFaderMenu.value = e.target.value;
    });

    voiceTrainingFader.addEventListener('input', (e) => {
      voiceTrainingFaderMenu.value = e.target.value;
    });

  }, 300); // <- pequeño delay para asegurar que el shadowRoot esté listo
});

window.addEventListener('DOMContentLoaded', () => {
  // ... tu código de inicialización ...
  const bigCircle = document.getElementById('unmatrix-lab-large-circle');
  // Ya que el círculo está correctamente posicionado:
  bigCircle.style.visibility = 'visible'; 
});

document.addEventListener('DOMContentLoaded', () => {
  const circles = document.querySelectorAll('.unmatrix-lab-small-circle');
  circles.forEach(circle => {
    const input = circle.querySelector('input');

    // Detectar interacción táctil
    circle.addEventListener('touchstart', () => {
      if (input.id !== 'circle5' && isPlaying && !isPaused) {
        tempAutoMuteGong();
      }
    });

    circle.addEventListener('touchend', () => {
      if (input.id !== 'circle5' && isPlaying && !isPaused) {
        tempAutoUnmuteGong();
      }
    });

    // Detectar interacción con el mouse
    circle.addEventListener('mousedown', () => {
      if (input.id !== 'circle5' && isPlaying && !isPaused) {
        tempAutoMuteGong();
      }
    });

    circle.addEventListener('mouseup', () => {
      if (input.id !== 'circle5' && isPlaying && !isPaused) {
        tempAutoUnmuteGong();
      }
    });
  });
});

// Referencia al label de Voice Training
const voiceTrainingLabel = document.getElementById('voice-training-label');

// Detectar clic en el label (incluye icono ⏰), pero IGNORAR si el clic vino del botón mute
voiceTrainingLabel.addEventListener('click', (e) => {
  // Evita que un clic en el botón "🔈" mute dispare el cambio de tiempo
  if (e.target.classList.contains('mute-button')) {
    return; 
  }

  // Solo si hay un track de voice_training cargado
  if (currentVoiceTraining !== 'voice_training_none' && musicVoiceTrainingBuffers[currentVoiceTraining]) {
    const trackDurationSec = musicVoiceTrainingBuffers[currentVoiceTraining].duration;
    const trackDurationMin = Math.ceil(trackDurationSec / 60);
    
    // Leer el valor actual de circle5 en minutos
    const currentC5 = parseInt(document.getElementById('circle5').value, 10) || 0;
    
    // Si circle5 es diferente al tiempo requerido, lo ajustamos (agregando o restando tiempo según sea necesario)
    if (currentC5 !== trackDurationMin) {
      document.getElementById('circle5').value = trackDurationMin;
      updateLargeCircle();
      saveSettingsToLocalStorage();
    }

      // Mute el gong (o chime) si aún no está muteado
    const gongMuteButton = document.querySelector('.mute-button[data-channel="gong"]');
    if (gongMuteButton && !isGongMuted) {
      toggleMute('gong', gongMuteButton);
    }

    // Feedback visual: ilumina el label en amarillo
    voiceTrainingLabel.classList.add('feedback');
    setTimeout(() => {
      voiceTrainingLabel.classList.remove('feedback');
    }, 1000);

    // Disparamos el mismo evento “input” que ocurre al mover circle5 manualmente
    const fakeInputEvent = new Event('input', { bubbles: true });
    inputC5.dispatchEvent(fakeInputEvent);
  } 
});


function highlightPreviewItem(itemId, enable) {
  // Si el itemId empieza con "gong_special", usamos "gong_special" para la búsqueda
  let effectiveId = itemId;
  if (itemId.indexOf("gong_special") === 0) {
    effectiveId = "gong_special";
  }

  const allDropdowns = [
    document.querySelector('gong-dropdown'),
    document.querySelector('ambient-dropdown'),
    document.querySelector('music-voice-training-dropdown')
  ].filter(Boolean);

  allDropdowns.forEach(dropdown => {
    if (!dropdown.shadowRoot) return;
    const item = dropdown.shadowRoot.querySelector(`.dropdown-item[data-value="${effectiveId}"]`);
    if (item) {
      if (enable) {
        item.classList.add('previewing');
      } else {
        item.classList.remove('previewing');
      }
    }
  });
}



let currentPreviewSource = null;
let currentPreviewGain   = null;
let currentPreviewItem   = null;
let previewTimeout       = null;

function previewAudio(itemId, buffer, previewDuration = 3) {
  // Si la sesión principal está en marcha y no está en pausa, no hacemos preview
if (isPlaying && !isPaused && 
    !itemId.startsWith("gong") && 
    !itemId.startsWith("final_gong")) {
  console.log("Sesión activa, no se lanza preview.");
  return;
}

  // Si se pide preview del mismo item, se detiene (toggle off)
  if (currentPreviewItem === itemId && currentPreviewSource) {
    stopCurrentPreview();
    return;
  }

  // Si hay un preview activo distinto, se detiene primero
  if (currentPreviewItem && currentPreviewItem !== itemId) {
    stopCurrentPreview();
  }

  // Guardamos qué ítem se está reproduciendo
  currentPreviewItem = itemId;
  // Ponemos la clase .previewing en ese ítem
  highlightPreviewItem(itemId, true);

  // Determinar si el preview se reproducirá en loop o no.
  // Para los items de menú gong (tanto "gong" como "final_gong") se reproducen una sola vez.
  // Para los items de Environment, Music o Voice Training se reproducen en loop.
  let loopPreview = false;
  if (itemId.startsWith("gong")) {
    loopPreview = false;
    previewDuration = 0; // Se usará onended para detener
  } else {
    loopPreview = true;
    previewDuration = 0; // Sin timeout; se mantendrá sonando hasta que se detenga externamente
  }

  // Asignamos el nuevo item a currentPreviewItem
  currentPreviewItem = itemId;

  // Creamos la fuente y un GainNode (sin fade in)
  const source = audioContext.createBufferSource();
  source.buffer = buffer;
  source.loop = loopPreview;
  const gainNode = audioContext.createGain();
  //gainNode.gain.value = 1.0; // Volumen a 1.0 sin rampas
    let previewVol = 1.0;
  if (itemId.startsWith("music")) {
    previewVol = parseInt(document.getElementById('music-fader').value, 10) / 100;
  } else if (itemId.startsWith("ambient1")) {
    previewVol = parseInt(document.getElementById('ambient1-fader').value, 10) / 100;
  } else if (itemId.startsWith("ambient2")) {
    previewVol = parseInt(document.getElementById('ambient2-fader').value, 10) / 100;
  } else if (itemId.startsWith("gong")) {
    previewVol = parseInt(document.getElementById('gong-fader').value, 10) / 100;
  } else if (itemId.startsWith("voice_training")) {
    previewVol = parseInt(document.getElementById('voice-training-fader').value, 10) / 100;
  }
  gainNode.gain.value = previewVol;

  currentPreviewGain = gainNode;
  //

  source.connect(gainNode).connect(audioContext.destination);
  source.start();

  // Si previewDuration es mayor a 0 se usa timeout; si es 0 se utiliza onended para detener al finalizar
  if (previewDuration > 0) {
    previewTimeout = setTimeout(() => {
      stopCurrentPreview();
    }, previewDuration * 1000);
  } else {
    source.onended = () => {
      stopCurrentPreview();
    };
  }

  // Guardamos en las variables globales
  currentPreviewSource = source;
  currentPreviewGain   = gainNode;
  currentPreviewItem   = itemId;// AYENCION NO SE QUE ES ESTO
}

function stopCurrentPreview() {
  // Cancelamos el timeout si existe
  if (previewTimeout) {
    clearTimeout(previewTimeout);
    previewTimeout = null;
  }

    // Quitamos la clase previewing del ítem actual
  if (currentPreviewItem) {
    highlightPreviewItem(currentPreviewItem, false);
  }
  
  // Guardamos en variables locales y borramos inmediatamente las globales
  const sourceToStop = currentPreviewSource;
  const gainToStop = currentPreviewGain;
  currentPreviewSource = null;
  currentPreviewGain   = null;
  currentPreviewItem   = null;

  if (sourceToStop && gainToStop) {
    const now = audioContext.currentTime;
    gainToStop.gain.cancelScheduledValues(now);
    gainToStop.gain.setValueAtTime(gainToStop.gain.value, now);
    // Realizamos un fade out rápido en 0.3s
    gainToStop.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

    // Luego, detenemos y desconectamos la fuente
    setTimeout(() => {
      try {
        sourceToStop.stop();
      } catch(e) {
        // En caso de que ya se haya detenido
      }
      sourceToStop.disconnect();
      gainToStop.disconnect();
    }, 300);
  }
}

  </script>

</body>
</html>
